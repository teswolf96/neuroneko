{% load static %}

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{% block title %}NeuroNeko{% endblock %}</title>
    <link rel="icon" href="{% static 'favicon.ico' %}">
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        .unselectable {
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* IE10+/Edge */
            user-select: none; /* Standard */
        }
        .is-dragging {
            opacity: 0.5;
            background-color: #4a5568; /* gray-700 */
        }
        .drop-hover {
            background-color: #2d3748 !important; /* gray-800, using important to override potential inline styles or more specific selectors */
            border: 2px dashed #718096; /* gray-500 */
        }
        .sidebar-locked {
            pointer-events: none; /* This makes the element and its children ignore mouse events */
            opacity: 0.7;         /* Optional: visual feedback to indicate it's locked */
        }
        /* Styles for Prompt Modal */
        .prompt-modal {
            display: none; /* Hidden by default */
            position: fixed;
            z-index: 100; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.6); /* Black w/ opacity */
        }
        .prompt-modal-content {
            background-color: #2d3748; /* gray-800 */
            margin: 10% auto; /* 10% from the top and centered */
            padding: 20px;
            border: 1px solid #4a5568; /* gray-700 */
            width: 60%; /* Could be more or less, depending on screen size */
            max-width: 700px;
            border-radius: 8px;
            color: #e2e8f0; /* gray-300 */
        }
        .prompt-modal-close-button {
            color: #cbd5e0; /* gray-400 */
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .prompt-modal-close-button:hover,
        .prompt-modal-close-button:focus {
            color: #f7fafc; /* gray-100 */
            text-decoration: none;
        }
        #prompt-filter-input {
            background-color: #4a5568; /* gray-700 */
            color: white;
            border: 1px solid #718096; /* gray-500 */
        }
        #prompt-list-container .prompt-item,
        #idea-list-container .prompt-item { /* Apply to both idea and prompt items */
            padding: 8px;
            cursor: pointer;
            border-bottom: 1px solid #4a5568; /* gray-700 */
        }
        #prompt-list-container .prompt-item:hover,
        #idea-list-container .prompt-item:hover { /* Apply to both idea and prompt items */
            background-color: #4a5568; /* gray-700 */
        }
        #prompt-list-container .prompt-item:last-child,
        #idea-list-container .prompt-item:last-child { /* Apply to both idea and prompt items */
            border-bottom: none;
        }
    </style>
    {% block extra_head %}{% endblock %}
</head>
<body class="bg-gray-900 text-white h-screen flex">

    <!-- Sidebar -->
    <aside class="w-72 bg-gray-800 p-1 flex flex-col">
            <div class="flex flex-row items-center mb-1 p-2"> <!-- Container for logo and name -->
            <img src="{% static 'neuroneko.png' %}" alt="NeuroNeko Logo" class="h-8 w-8 mr-2 rounded-full"> <!-- Logo image -->
            <span class="text-xl font-semibold text-white">NeuroNeko</span> <!-- Name -->
        </div>
        <div class="flex items-center space-x-2 mb-4">
            <a href="{% url 'create_new_chat' %}" class="bg-gray-700 hover:bg-gray-600 text-white px-4 py-2 rounded text-sm text-center flex-grow">
                + New Chat
            </a>
            <button id="new-folder-button" title="New Folder" class="bg-gray-700 hover:bg-gray-600 text-white p-2 rounded">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path d="M2 6a2 2 0 012-2h5l2 2h5a2 2 0 012 2v6a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" />
                </svg>
            </button>
        </div>

        <!-- Search Bar -->
        <input type="text" id="sidebar-search" placeholder="Search chats & folders..." class="w-full bg-gray-700 text-white p-2 rounded mb-2 text-sm focus:outline-none focus:ring-1 focus:ring-blue-500">

        <div class="flex-1 overflow-y-auto"> <!-- Added overflow-y-auto for scrollable chat list -->
            <!-- Folder Dropdown -->
            <details class="group" id="main-folders-details" open>
                <summary class="text-sm font-bold text-gray-400 mt-4 mb-2 px-2 cursor-pointer list-none flex items-center justify-between">
                    <span class="unselectable"><!-- <span class="group-open:rotate-90 inline-block mr-1 transition-transform duration-150 transform">‚ñ∂</span>--> Folders</span>
                </summary>
                <div class="ml-4"> <!-- Indent folder contents slightly more -->
                    {% for item in folder_structure %}
                        {% if item.name != "Other Chats" %}
                            <details class="group mt-2 folder-item-container" data-folder-id="{{ item.id }}" {% if item.is_open %}open{% endif %}> <!-- Wrapper for each folder, now a details element -->
                                <summary class="text-sm font-semibold text-gray-300 mb-1 px-2 cursor-pointer list-none flex items-center justify-between">
                                    <span class="folder-name-display flex-grow unselectable"><!-- <span class="group-open:rotate-90 inline-block mr-1 transition-transform duration-150 transform">‚ñ∂</span>--> {{ item.name }}</span>
                                    <div class="folder-actions flex items-center space-x-1 ml-2 hidden" data-folder-name="{{ item.name|escapejs }}" data-folder-id="{{ item.id }}">
                                        <button class="create-chat-in-folder-button text-gray-400 hover:text-white text-xs focus:outline-none" title="New Chat in Folder">‚ûï</button>
                                        <button class="rename-folder-button text-gray-400 hover:text-white text-xs focus:outline-none" title="Rename Folder">‚úèÔ∏è</button>
                                        <button class="delete-folder-button text-gray-400 hover:text-white text-xs focus:outline-none" title="Delete Folder">üóëÔ∏è</button>
                                    </div>
                                </summary>
                                <div class="ml-4 folder-drop-target" data-folder-id="{{ item.id }}"> <!-- Indent chats within each folder, ADDED folder-drop-target and data-folder-id -->
                                    {% if item.chats %}
                                        <ul class="space-y-1">
                                            {% for chat in item.chats %}
                                                <li class="text-white py-1 hover:bg-gray-700 rounded px-2 text-sm chat-item flex items-center justify-between" data-chat-id="{{ chat.id }}" data-chat-full-title="{{ chat.title }}" draggable="true">
                                                    <a href="#" class="chat-link flex-grow" data-chat-id="{{ chat.id }}">{{ chat.title }}</a>
                                                    <div class="chat-actions flex space-x-2 ml-2 hidden">
                                                        <button class="rename-chat-button text-gray-400 hover:text-white text-xs focus:outline-none" title="Rename">‚úèÔ∏è</button>
                                                        <button class="delete-chat-button text-gray-400 hover:text-white text-xs focus:outline-none" title="Delete" data-chat-id="{{ chat.id }}">üóëÔ∏è</button>
                                                    </div>
                                                </li>
                                            {% endfor %}
                                        </ul>
                                    {% else %}
                                        <p class="text-xs text-gray-500 ml-2 px-2">No chats in this folder.</p>
                                    {% endif %}
                                </div>
                            </details>
                        {% endif %}
                    {% endfor %}
                </div>
            </details>

            <!-- Other Chats (Collapsible) -->
            {% for item in folder_structure %}
                {% if item.name == "Other Chats" %}
                    {% if item.chats %} <!-- Only show "Other Chats" section if it has chats -->
                    <details class="group" open> <!-- Default open -->
                        <summary class="text-sm font-bold text-gray-400 mt-4 mb-2 px-2 cursor-pointer list-none flex items-center unselectable">
                             <!-- <span class="group-open:rotate-90 inline-block mr-1 transition-transform duration-150 transform">‚ñ∂</span>--> {{ item.name }}
                        </summary>
                        <div class="ml-4 folder-drop-target" data-folder-id="other-chats-target"> <!-- Indent "Other Chats" contents, ADDED folder-drop-target and data-folder-id -->
                            <ul class="space-y-1">
                                {% for chat in item.chats %}
                                    <li class="text-white py-1 hover:bg-gray-700 rounded px-2 text-sm chat-item flex items-center justify-between" data-chat-id="{{ chat.id }}" data-chat-full-title="{{ chat.title }}" draggable="true">
                                        <a href="#" class="chat-link flex-grow" data-chat-id="{{ chat.id }}">{{ chat.title }}</a>
                                        <div class="chat-actions flex space-x-2 ml-2 hidden">
                                            <button class="rename-chat-button text-gray-400 hover:text-white text-xs focus:outline-none" title="Rename">‚úèÔ∏è</button>
                                            <button class="delete-chat-button text-gray-400 hover:text-white text-xs focus:outline-none" title="Delete" data-chat-id="{{ chat.id }}">üóëÔ∏è</button>
                                        </div>
                                    </li>
                                {% endfor %}
                            </ul>
                        </div>
                    </details>
                    {% endif %}
                {% endif %}
            {% endfor %}
        </div>

        <div class="space-y-2 mt-4">
            <button class="text-sm text-gray-400 flex items-center">Hello, {{ user.username }}!</button>
            <!-- <button class="text-sm text-gray-400 flex">Manage Tags</button> Placeholder -->
            <!-- <button class="text-sm text-gray-400 flex">Import / Export</button> Placeholder -->
            <a href="{% url 'manage_prompts' %}" class="text-sm text-gray-400 flex hover:text-white">Manage Prompts</a>
            <a href="{% url 'manage_ideas' %}" class="text-sm text-gray-400 flex hover:text-white">Manage Ideas</a>
            <a href="{% url 'api_config' %}" class="text-sm text-gray-400 flex hover:text-white">API Configuration</a>
            <a href="{% url 'user_settings' %}" class="text-sm text-gray-400 flex hover:text-white">Settings</a>
            <a href="{% url 'logout' %}" class="text-sm text-gray-400 flex hover:text-white">Logout</a>
        </div>
    </aside>

    <!-- Main Content -->
    <main class="flex-1 p-1 flex flex-col h-screen"> <!-- Added flex flex-col h-screen for layout -->
        {% block content %}
        <div class="bg-gray-800 p-1 rounded"> <!-- Added mb-4 for spacing -->
            <div class="flex items-center justify-start text-sm mb-2 space-x-4">
                <div>
                    Model: 
                    <select id="chat-model-select" class="bg-gray-700 text-white text-sm rounded p-1 focus:outline-none focus:ring-1 focus:ring-blue-500">
                        {% if available_models %}
                            {% for model in available_models %}
                                <option value="{{ model.id }}">{{ model.name }}</option>
                            {% endfor %}
                        {% else %}
                            <option value="">No models available</option>
                        {% endif %}
                    </select>
                </div>
                <span>Max Output: 64000</span> <!-- This might also become dynamic later -->
                <span>Temperature: <span id="chat-model-temp">0.8</span></span>
                <!-- <span>Top-p: 1</span>
                <span>Presence Penalty: 0</span>
                <span>Frequency Penalty: 0</span> -->
            </div>

            <!-- <div class="bg-gray-700 p-4 rounded mb-4">
                <span class="text-sm">System</span>
                <p id="chat-system-prompt">You are playing the role of a friendly and helpful chatbot.</p>
            </div> -->
        </div> <!-- Moved closing div for settings/system prompt block -->

        <!-- Chat Messages Area -->
        <div class="overflow-y-auto w-full flex flex-col flex-1">
            <div id="chat-messages-container" class="flex-grow w-full bg-gray-750 max-w-5xl mx-auto px-4 py-2 rounded mb-4 space-y-2">
                <p class="text-gray-500">Select a chat to view messages.</p> 
            </div>

            <!-- Input Area -->
            <div class="bg-gray-800 p-2 rounded mt-auto"> <!-- mt-auto to push to bottom -->
                <div class="bg-gray-700 p-2 rounded flex items-start space-x-2">
                    <!-- <div class="bg-red-500 px-2 py-1 rounded">User</div> -->
                    <textarea id="message-input" class="w-full bg-gray-800 p-2 rounded text-white" rows="4" placeholder="Type a message..."></textarea>
                    <!-- Button column for Generate, Save, Prompt, Idea -->
                    <div class="flex flex-col space-y-1">
                        <button class="bg-green-500 px-4 py-2 rounded w-full">Generate</button>
                        <button class="bg-gray-600 px-4 py-2 rounded w-full">Save</button>
                        <div class="flex space-x-1 mt-1">
                            <button id="open-prompt-modal-button" class="bg-gray-600 px-3 py-1 rounded text-xs flex-grow">Prompt</button>
                            <button id="open-idea-modal-button" class="bg-gray-600 px-3 py-1 rounded text-xs flex-grow">Idea</button>
                        </div>
                    </div>
                </div>
                <div id="cost-estimation-display" class="text-xs text-gray-400 mt-1 pl-1">Input Tokens: 0, Est. Cost: $0.000000 (Note: This is an estimate)</div>
                <!-- The div that previously held Prompt and Idea buttons is removed by not including it here -->
                <div class="flex space-x-2 mt-2">
                    <button id="regen-title-button" class="bg-gray-700 px-3 py-1 rounded">Regen Title</button>
                    <!-- <button class="bg-gray-700 px-3 py-1 rounded">Download Chat</button> -->
                    <button id="clone-chat-button" class="bg-gray-700 px-3 py-1 rounded">Clone Chat</button>
                    <button id="continue-chat-button" class="bg-gray-700 px-3 py-1 rounded">Continue</button>
                </div>
            </div> <!-- Closing div for input area -->
                    </div>

        {% endblock %}
    </main>

    <!-- Prompt Modal HTML -->
    <div id="prompt-modal" class="prompt-modal">
        <div class="prompt-modal-content">
            <span id="prompt-modal-close-button" class="prompt-modal-close-button">&times;</span>
            <h2 class="text-xl font-semibold mb-4">Select a Prompt</h2>
            <input type="text" id="prompt-filter-input" class="w-full p-2 mb-4 rounded" placeholder="Filter prompts...">
            <div id="prompt-list-container" class="max-h-60 overflow-y-auto">
                <!-- Prompts will be loaded here -->
            </div>
        </div>
    </div>

    <!-- Idea Modal HTML (Copied and modified from Prompt Modal) -->
    <div id="idea-modal" class="prompt-modal"> <!-- Reused prompt-modal class for basic styling, but ID is idea-modal -->
        <div class="prompt-modal-content"> <!-- Reused prompt-modal-content class -->
            <span id="idea-modal-close-button" class="prompt-modal-close-button">&times;</span> <!-- ID changed -->
            <h2 class="text-xl font-semibold mb-4">Select an Idea</h2> <!-- Title changed -->
            <input type="text" id="idea-filter-input" class="w-full p-2 mb-4 rounded" placeholder="Filter ideas..."> <!-- ID and placeholder changed -->
            <div id="idea-list-container" class="max-h-60 overflow-y-auto">
                <!-- Ideas will be loaded here -->
            </div>
        </div>
    </div>

    {% block extra_js %}
    <script>
        const userChatFontSize = '{{ user.settings.chat_font_size|default:"text-base" }}';
        document.addEventListener('DOMContentLoaded', function () {
            const chatItems = document.querySelectorAll('.chat-item');
            const chatModelSelectEl = document.getElementById('chat-model-select'); // Changed from chatModelNameEl
            const chatModelTempEl = document.getElementById('chat-model-temp');
            // const chatSystemPromptEl = document.getElementById('chat-system-prompt'); // System prompt display removed for now
            const chatMessagesContainerEl = document.getElementById('chat-messages-container');
            const messageInputTextarea = document.getElementById('message-input'); // Added ID to textarea
            const saveButton = document.querySelector('button.bg-gray-600.px-4.py-2.rounded.w-full');
            const generateButton = document.querySelector('button.bg-green-500.px-4.py-2.rounded.w-full'); // Generate button
            const newFolderButton = document.getElementById('new-folder-button');
            // chatMessagesContainerEl, messageInputTextarea, chatModelSelectEl are defined above.
            const sidebarElement = document.querySelector('aside');

            // Prompt Modal Elements
            const promptModal = document.getElementById('prompt-modal');
            const openPromptModalButton = document.getElementById('open-prompt-modal-button');
            const closePromptModalButton = document.getElementById('prompt-modal-close-button');
            const promptFilterInput = document.getElementById('prompt-filter-input');
            const promptListContainer = document.getElementById('prompt-list-container');
            let allPrompts = [];
            let activePromptTargetTextarea = null; // Initialize to null or to messageInputTextarea

            // Idea Modal Elements
            const ideaModal = document.getElementById('idea-modal');
            const openIdeaModalButton = document.getElementById('open-idea-modal-button');
            const closeIdeaModalButton = document.getElementById('idea-modal-close-button');
            const ideaFilterInput = document.getElementById('idea-filter-input');
            const ideaListContainer = document.getElementById('idea-list-container');
            let allIdeas = [];
            // activePromptTargetTextarea is reused for ideas as well


            let currentActiveChatLi = null;
            let currentChatId = null; // To store the ID of the currently active chat
            let currentChatRootMessageId = null; // To store the root message ID of the active chat
            const lastActiveChatIdFromDjango = '{{ last_active_chat_id|default_if_none:"" }}';
            let chatSocket = null;
            let currentAssistantMessageId = null; // Store ID of the assistant message being streamed into
            let currentAssistantMessageContentEl = null; // Store the content DOM element of the assistant message
            const costEstimationDisplayEl = document.getElementById('cost-estimation-display');

            // Cancel button (initially hidden)
            const cancelGenerationButton = document.createElement('button');
            cancelGenerationButton.id = 'cancel-generation-button';
            cancelGenerationButton.textContent = 'Cancel';
            cancelGenerationButton.classList.add('bg-red-500', 'hover:bg-red-600', 'text-white', 'px-4', 'py-2', 'rounded', 'w-full', 'hidden');
            // Insert it after the Generate button
            if (generateButton && generateButton.parentElement) {
                generateButton.parentElement.insertBefore(cancelGenerationButton, generateButton.nextSibling);
            }

            cancelGenerationButton.addEventListener('click', function() {
                if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
                    chatSocket.send(JSON.stringify({ type: 'cancel_generation' }));
                    this.textContent = 'Cancelling...';
                    this.disabled = true;
                }
            });


            function connectWebSocket(chatId) {
                if (chatSocket) {
                    chatSocket.close();
                }
                const wsScheme = window.location.protocol === "https:" ? "wss" : "ws";
                // Ensure chat_id is valid before trying to connect
                if (!chatId || chatId === 'null' || chatId === 'undefined') {
                    console.error("Invalid chat_id for WebSocket connection:", chatId);
                    // Optionally, display an error to the user or prevent connection attempt
                    return;
                }
                const wsPath = `${wsScheme}://${window.location.host}/ws/chat/${chatId}/`;
                chatSocket = new WebSocket(wsPath);

                chatSocket.onopen = function(e) {
                    console.log(`WebSocket connection opened for chat ${chatId}`);
                    requestCostEstimation(); // Call here to ensure socket is open for initial estimation
                };

                chatSocket.onmessage = function(e) {
                    const data = JSON.parse(e.data);
                    // console.log("WebSocket message received:", data);

                    switch (data.type) {
                        case 'user_message_created':
                            // The user message is already added optimistically by renderMessage
                            // or we can refresh the specific message if needed.
                            // For now, we assume the UI is up-to-date or will be with the assistant placeholder.
                            // We might need to update its ID if it was a temporary one.
                            // Let's ensure the message div for user message exists and has correct ID.
                            let userMsgDiv = chatMessagesContainerEl.querySelector(`[data-message-id="${data.parent_id}"]`); // This assumes parent_id is the one before user's
                                                                                                                            // This logic needs to be more robust if user message is added dynamically by JS first.
                                                                                                                            // For now, let's assume the user message is the one whose parent is data.parent_id
                                                                                                                            // and it's the last one.
                            const allMessages = chatMessagesContainerEl.querySelectorAll('[data-message-id]');
                            if (allMessages.length > 0) {
                                const potentialUserMsg = allMessages[allMessages.length -1]; // last message
                                if (potentialUserMsg && potentialUserMsg.querySelector('select').value === 'user') {
                                     potentialUserMsg.setAttribute('data-message-id', data.message_id);
                                }
                            }
                            chatMessagesContainerEl.scrollTop = chatMessagesContainerEl.scrollHeight;
                            break;
                        case 'assistant_message_placeholder_created':
                            currentAssistantMessageId = data.message_id;
                            // Check if the message element already exists
                            let existingMsgDiv = chatMessagesContainerEl.querySelector(`[data-message-id="${currentAssistantMessageId}"]`);
                            if (!existingMsgDiv) {
                                // Only render if it doesn't exist
                                const newAssistantMsg = {
                                    id: data.message_id,
                                    role: data.role,
                                    content: "", // Placeholder is empty
                                    parent_id: data.parent_id
                                };
                                const messagesInUI = chatMessagesContainerEl.querySelectorAll('[data-message-id]');
                                renderMessage(newAssistantMsg, chatMessagesContainerEl, true, messagesInUI.length, currentChatRootMessageId);
                            }
                            // Now, query for the element (either pre-existing or newly rendered)
                            currentAssistantMessageContentEl = chatMessagesContainerEl.querySelector(`[data-message-id="${currentAssistantMessageId}"] .prose`);
                            chatMessagesContainerEl.scrollTop = chatMessagesContainerEl.scrollHeight;
                            break;
                        case 'lock_sidebar':
                            lockSidebar();
                            break;
                        case 'unlock_sidebar':
                            unlockSidebar();
                            // Reset Generate/Cancel buttons
                            generateButton.disabled = false;
                            generateButton.textContent = 'Generate';
                            messageInputTextarea.disabled = false;
                            cancelGenerationButton.classList.add('hidden');
                            cancelGenerationButton.disabled = false;
                            cancelGenerationButton.textContent = 'Cancel';
                            currentAssistantMessageId = null;
                            currentAssistantMessageContentEl = null;
                            break;
                        case 'stream_chunk':
                            if (data.assistant_message_id === currentAssistantMessageId && currentAssistantMessageContentEl) {
                                // Append text and re-render Markdown
                                const currentRawContent = currentAssistantMessageContentEl.dataset.rawContent || "";
                                const newRawContent = currentRawContent + data.text_delta;
                                currentAssistantMessageContentEl.dataset.rawContent = newRawContent;
                                currentAssistantMessageContentEl.textContent = newRawContent;
                                chatMessagesContainerEl.scrollTop = chatMessagesContainerEl.scrollHeight;
                            }
                            break;
                        case 'stream_end':
                            if (data.assistant_message_id === currentAssistantMessageId && currentAssistantMessageContentEl) {
                                currentAssistantMessageContentEl.dataset.rawContent = data.full_content; // Store final raw content
                                currentAssistantMessageContentEl.textContent = data.full_content;
                            }
                            // UI reset is handled by unlock_sidebar which should follow
                            break;
                        case 'stream_cancelled':
                             if (data.assistant_message_id === currentAssistantMessageId && currentAssistantMessageContentEl) {
                                // Content should already be updated by last chunk before cancel or by consumer saving partial
                                console.log("Stream was cancelled by server or client ack.");
                            }
                            // UI reset is handled by unlock_sidebar
                            break;
                        case 'stream_error':
                            if (data.assistant_message_id && data.assistant_message_id === currentAssistantMessageId && currentAssistantMessageContentEl) {
                                currentAssistantMessageContentEl.innerHTML = `<p class="text-red-400">Error: ${data.error}</p>`;
                            } else {
                                // General error display or append to last message
                                const errorDisplay = document.createElement('p');
                                errorDisplay.classList.add('text-red-400', 'p-2');
                                errorDisplay.textContent = `Server Error: ${data.error}`;
                                chatMessagesContainerEl.appendChild(errorDisplay);
                            }
                            // UI reset is handled by unlock_sidebar
                            break;
                        case 'info':
                            console.log("Server Info:", data.message);
                            // Could display this info somewhere if needed
                            break;
                        case 'cost_estimation_result':
                            if (costEstimationDisplayEl) {
                                costEstimationDisplayEl.textContent = `Input Tokens: ${data.token_count}, Est. Cost: $${data.estimated_cost} (Note: This is an estimate)`;
                            }
                            break;
                    }
                };

                chatSocket.onclose = function(e) {
                    console.error('Chat socket closed unexpectedly');
                    // Optionally, try to reconnect or notify user
                };

                chatSocket.onerror = function(err) {
                    console.error('WebSocket encountered error: ', err.message, 'Closing socket');
                    chatSocket.close();
                };
            }

            // Function to render a single message
            function renderMessage(msg, container, showPlusIcon, messageIndex, chatRootMessageId) { // Added chatRootMessageId
                const messageDiv = document.createElement('div');
                messageDiv.classList.add('p-3', 'rounded-lg', 'break-words', 'mb-2', 'relative', 'text-gray-100');
                
                let messageIdToSet = msg.id;
                if (msg.id === null || msg.id === undefined || String(msg.id).startsWith('temp-')) {
                    // Use provided temp ID or generate one if msg.id is truly null/undefined
                    messageIdToSet = msg.id || `temp-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                    if (!msg.id) console.warn("Rendered message with newly generated temporary ID for msg:", msg);
                }
                messageDiv.setAttribute('data-message-id', messageIdToSet);


                // Role Dropdown
                const roleSelect = document.createElement('select');
                roleSelect.classList.add('bg-gray-500', 'text-white', 'text-xs', 'font-semibold', 'rounded', 'p-1', 'mb-1', 'mr-2', 'focus:outline-none', 'focus:ring-1', 'focus:ring-blue-400');
                const roles = ['User', 'Assistant', 'System'];
                roles.forEach(r => {
                    const option = document.createElement('option');
                    option.value = r.toLowerCase();
                    option.textContent = r;
                    if (msg.role && msg.role.toLowerCase() === r.toLowerCase()) {
                        option.selected = true;
                    } else if (!msg.role && r.toLowerCase() === 'assistant') { // Default to assistant if role is missing
                        option.selected = true;
                    }
                    roleSelect.appendChild(option);
                });

                // Event listener for role change
                roleSelect.addEventListener('change', function() {
                    const messageId = messageDiv.dataset.messageId;
                    const newRole = this.value;
                    if (!currentChatId || !messageId) {
                        console.error('Chat ID or Message ID is missing for role update.');
                        alert('Could not update role: Chat or Message ID missing.');
                        return;
                    }

                    fetch(`/api/chat/${currentChatId}/message/${messageId}/update_role/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': '{{ csrf_token }}' // Make sure CSRF token is available
                        },
                        body: JSON.stringify({ new_role: newRole })
                    })
                    .then(response => {
                        if (!response.ok) {
                            return response.json().then(err => { throw new Error(err.error || `HTTP error! status: ${response.status}`) });
                        }
                        return response.json();
                    })
                    .then(data => {
                        console.log('Role update successful:', data.message);
                        // Optionally, provide user feedback, e.g., a small temporary notification
                        // For now, just logging. The visual change is immediate due to dropdown selection.
                    })
                    .catch(error => {
                        console.error('Error updating message role:', error);
                        alert('Error updating role: ' + error.message);
                        // Optionally, revert the dropdown if the backend update fails
                        // For now, we leave it as is, assuming the user might retry or it's a transient issue.
                    });
                });

                const contentP = document.createElement('div'); // Changed to div to better accommodate block elements from Markdown
                contentP.classList.add(userChatFontSize, 'prose', 'prose-sm', 'prose-invert', 'max-w-none', 'whitespace-pre-line'); // Added prose classes and whitespace-pre-line, and dynamic font size
                const rawContent = msg.content || ''; // Ensure rawContent is defined
                contentP.textContent = rawContent; // Use textContent for plain text
                contentP.dataset.rawContent = rawContent; // Store raw content for easier updates

                // Alternating grey backgrounds
                if (messageIndex % 2 === 0) {
                    messageDiv.classList.add('bg-gray-600');
                } else {
                    messageDiv.classList.add('bg-gray-700');
                }

                // Alignment based on role
                if (msg.role === 'user') {
                    messageDiv.classList.add('ml-auto');
                } else { // assistant or system roles
                    messageDiv.classList.add('mr-auto');
                }
                // Ensure roleSelect has consistent styling
                roleSelect.classList.add('bg-gray-500', 'text-white');


                messageDiv.appendChild(roleSelect);
                messageDiv.appendChild(contentP);

                // Footer for icons
                const footerDiv = document.createElement('div');
                footerDiv.classList.add('relative', 'h-5', 'mt-1'); // Height to contain icons, mt-1 for spacing

                // Action Icons (Copy, Edit, Delete) - bottom-right
                const iconsDiv = document.createElement('div');
                iconsDiv.classList.add('absolute', 'bottom-0', 'right-0', 'flex', 'space-x-2');

                const copyButton = document.createElement('button');
                copyButton.innerHTML = 'üìÑ'; // Unicode for Copy
                copyButton.title = 'Copy';
                copyButton.classList.add('text-xs', 'hover:text-gray-300', 'focus:outline-none');
                copyButton.addEventListener('click', function() {
                    // For Markdown, copying innerText might be more appropriate to get a plain text version
                    const textToCopy = contentP.innerText; 
                    navigator.clipboard.writeText(textToCopy)
                        .then(() => {
                            // Optional: Provide feedback to the user, e.g., change icon or show a tooltip
                            copyButton.innerHTML = '‚úÖ'; // Checkmark to indicate success
                            copyButton.title = 'Copied!';
                            setTimeout(() => {
                                copyButton.innerHTML = 'üìÑ'; // Revert to original icon
                                copyButton.title = 'Copy';
                            }, 1500); // Revert after 1.5 seconds
                        })
                        .catch(err => {
                            console.error('Failed to copy text: ', err);
                            alert('Failed to copy text. Your browser might not support this feature or permission was denied.');
                        });
                });

                const editButton = document.createElement('button');
                editButton.innerHTML = '‚úèÔ∏è'; // Unicode for Edit
                editButton.title = 'Edit';
                editButton.classList.add('text-xs', 'hover:text-gray-300', 'focus:outline-none');
                editButton.addEventListener('click', function() {
                    const messageId = messageDiv.dataset.messageId;
                    if (!messageId || !currentChatId) {
                        alert('Error: Message or Chat ID missing.');
                        return;
                    }

                    // Prevent multiple edit UIs
                    if (messageDiv.querySelector('.editing-interface')) {
                        return;
                    }

                    contentP.style.display = 'none';
                    iconsDiv.style.display = 'none'; // Hide the standard icons

                    const editingInterfaceDiv = document.createElement('div');
                    editingInterfaceDiv.classList.add('editing-interface', 'my-2'); // Added my-2 for spacing

                    const textarea = document.createElement('textarea');
                    // When editing, we should edit the raw Markdown source, not the rendered HTML's textContent
                    textarea.value = msg.content; // Assuming msg.content holds the raw markdown
                    textarea.classList.add('w-full', 'bg-gray-800', 'p-2', 'rounded', 'text-white', 'text-lg', 'border', 'border-gray-600', 'focus:border-blue-500', 'focus:ring-1', 'focus:ring-blue-500');
                    textarea.style.resize = 'vertical'; // Allow vertical resize by user if browser supports
                    const minHeightPx = 40; // Approx 2 lines with padding
                    textarea.style.minHeight = `${minHeightPx}px`;

                    textarea.addEventListener('input', function () {
                        this.style.height = 'auto';
                        this.style.height = Math.max(this.scrollHeight + 5, minHeightPx) + 'px'; // Added 5px buffer
                    });


                    const editControlsDiv = document.createElement('div');
                    editControlsDiv.classList.add('flex', 'justify-between', 'items-center', 'mt-2');

                    const saveEditButton = document.createElement('button');
                    saveEditButton.textContent = 'Save';
                    saveEditButton.classList.add('bg-blue-500', 'hover:bg-blue-600', 'text-white', 'px-3', 'py-1', 'rounded', 'text-sm');
                    saveEditButton.addEventListener('click', function() {
                        const newText = textarea.value;
                        fetch(`/api/chat/${currentChatId}/message/${messageId}/update_content/`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': '{{ csrf_token }}'
                            },
                            body: JSON.stringify({ new_content: newText })
                        })
                        .then(response => {
                            if (!response.ok) {
                                return response.json().then(err => { throw new Error(err.error || `HTTP error! status: ${response.status}`) });
                            }
                            return response.json();
                        })
                        .then(data => {
                            // Update the raw content store (msg.content) if possible, or re-fetch for consistency
                            msg.content = newText; // Update local msg object
                            contentP.textContent = newText; // Use textContent for plain text
                            // Restore UI
                            editingInterfaceDiv.remove();
                            contentP.style.display = '';
                            iconsDiv.style.display = 'flex'; // Assuming it was flex
                        })
                        .catch(error => {
                            console.error('Error updating message content:', error);
                            alert('Error saving message: ' + error.message);
                            // Optionally, restore UI even on error, or leave textarea
                            // For now, let's restore it to avoid getting stuck
                            editingInterfaceDiv.remove();
                            contentP.style.display = '';
                            iconsDiv.style.display = 'flex';
                        });
                    });

                    const generateButtonInEditMenu = document.createElement('button');
                    generateButtonInEditMenu.textContent = 'Generate';
                    generateButtonInEditMenu.classList.add('bg-green-500', 'hover:bg-green-600', 'text-white', 'px-3', 'py-1', 'rounded', 'text-sm');
                    

                    const cancelEditButton = document.createElement('button');
                    cancelEditButton.textContent = 'Cancel';
                    cancelEditButton.classList.add('bg-red-500', 'hover:bg-red-600', 'text-white', 'px-3', 'py-1', 'rounded', 'text-sm');
                    cancelEditButton.addEventListener('click', function() {
                        // Restore UI
                        editingInterfaceDiv.remove();
                        contentP.style.display = '';
                        iconsDiv.style.display = 'flex'; // Assuming it was flex
                    });

                    generateButtonInEditMenu.addEventListener('click', function() {
                        const editedMessageId = messageId; // from outer scope of editButton listener
                        const newText = textarea.value; // Content from the textarea in edit UI

                        if (!chatSocket || chatSocket.readyState !== WebSocket.OPEN) {
                            alert('WebSocket is not connected. Please try selecting the chat again or refresh.');
                            return;
                        }
                        const selectedModelId = chatModelSelectEl.value;
                        if (!selectedModelId) {
                            alert('Please select an AI model.');
                            return;
                        }

                        // Step 1: Save the content first (similar to saveEditButton)
                        fetch(`/api/chat/${currentChatId}/message/${editedMessageId}/update_content/`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': '{{ csrf_token }}'
                            },
                            body: JSON.stringify({ new_content: newText })
                        })
                        .then(response => {
                            if (!response.ok) {
                                return response.json().then(err => { throw new Error(err.error || `HTTP error! status: ${response.status}`) });
                            }
                            return response.json();
                        })
                        .then(saveData => {
                            // Content saved successfully
                            msg.content = newText; // Update local msg object's content
                            contentP.textContent = newText; // Use textContent for plain text
                            contentP.dataset.rawContent = newText;

                            // Restore UI from editing mode
                            editingInterfaceDiv.remove();
                            contentP.style.display = '';
                            iconsDiv.style.display = 'flex';

                            // Now proceed with generation logic
                            const hasChildren = msg.children && msg.children.length > 0;

                            if (!hasChildren) {
                                // Scenario 3: No children - Generate reply to this edited message
                                console.log(`Generate reply to message ID: ${editedMessageId}`);
                                chatSocket.send(JSON.stringify({
                                    type: 'generate_reply_to_message',
                                    parent_message_id: editedMessageId,
                                    model_id: selectedModelId
                                }));
                                // UI locking will be handled by lock_sidebar message from consumer
                            } else {
                                // Scenario 4: Has children - Create new sibling for active child and generate into it
                                let sourceMessageForSiblingId = msg.active_child_id;
                                if (!sourceMessageForSiblingId && msg.children && msg.children.length > 0) {
                                    // Fallback: if no active_child_id is set, but children exist,
                                    // use the first child as the source for creating a sibling.
                                    // This assumes children are ordered, e.g., by creation date.
                                    // The backend's get_chat_details_api orders children by created_at.
                                    console.warn("No active_child_id, using first child to create sibling for.");
                                    sourceMessageForSiblingId = msg.children[0].id; 
                                }

                                if (!sourceMessageForSiblingId) {
                                    alert("Error: Cannot determine the message to create a sibling for.");
                                    unlockGlobalUIAfterGenerationEnd(); // Ensure UI is not stuck locked
                                    return;
                                }
                                
                                console.log(`Create sibling for message ID: ${sourceMessageForSiblingId} (child of ${editedMessageId}) and generate into new sibling.`);
                                fetch(`/api/chat/${currentChatId}/message/${sourceMessageForSiblingId}/add_sibling/`, {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'X-CSRFToken': '{{ csrf_token }}'
                                    }
                                })
                                .then(response => response.json())
                                .then(siblingData => {
                                    if (siblingData.status === 'success' && siblingData.new_message_id) {
                                        const newSiblingId = siblingData.new_message_id;

                                        // Refresh chat display to show the new empty sibling
                                        const activeChatListItem = document.querySelector('.chat-item.bg-blue-600');
                                        if (activeChatListItem) {
                                            activeChatListItem.click(); // This re-fetches and re-renders
                                        } else if (currentChatId) { // Fallback
                                            const targetChatLink = document.querySelector(`.chat-link[data-chat-id="${currentChatId}"]`);
                                            if (targetChatLink) targetChatLink.closest('.chat-item')?.click();
                                        }
                                        
                                        // Wait for DOM update after re-render
                                        setTimeout(() => {
                                            const newSiblingElementProse = chatMessagesContainerEl.querySelector(`[data-message-id="${newSiblingId}"] .prose`);
                                            if (newSiblingElementProse) {
                                                currentAssistantMessageId = newSiblingId;
                                                currentAssistantMessageContentEl = newSiblingElementProse;
                                                currentAssistantMessageContentEl.dataset.rawContent = ""; // Ensure it's empty
                                                currentAssistantMessageContentEl.innerHTML = "";
                                                
                                                chatSocket.send(JSON.stringify({
                                                    type: 'generate_into_empty_message',
                                                    target_message_id: newSiblingId,
                                                    model_id: selectedModelId
                                                }));
                                            } else {
                                                console.error("Could not find new sibling element .prose in DOM after refresh for generation.");
                                                alert("Error preparing for generation. UI might be out of sync.");
                                                unlockGlobalUIAfterGenerationEnd(); // Unlock UI
                                            }
                                        }, 300); // Adjusted timeout, might need tuning
                                    } else {
                                        alert('Error creating sibling message: ' + (siblingData.error || 'Unknown error'));
                                        unlockGlobalUIAfterGenerationEnd(); // Unlock UI
                                    }
                                })
                                .catch(error => {
                                    console.error('Error in add_sibling_message_api call:', error);
                                    alert('Error setting up sibling for generation: ' + error.message);
                                    unlockGlobalUIAfterGenerationEnd(); // Unlock UI
                                });
                            }
                        })
                        .catch(error => {
                            console.error('Error updating message content before generation:', error);
                            alert('Error saving message before generation: ' + error.message);
                            // No need to call unlockGlobalUIAfterGenerationEnd here as generation hasn't started
                        });
                    });

                    const leftButtonsDiv = document.createElement('div');
                    leftButtonsDiv.classList.add('flex', 'space-x-2');

                    leftButtonsDiv.appendChild(saveEditButton);
                    leftButtonsDiv.appendChild(generateButtonInEditMenu);
                    leftButtonsDiv.appendChild(cancelEditButton); // Moved Cancel to the left group

                    const rightButtonsDiv = document.createElement('div');
                    rightButtonsDiv.classList.add('flex', 'space-x-2');

                    // New "Prompt" button for the edit interface
                    const promptEditButton = document.createElement('button');
                    promptEditButton.textContent = 'Prompt';
                    promptEditButton.classList.add('bg-indigo-500', 'hover:bg-indigo-600', 'text-white', 'px-3', 'py-1', 'rounded', 'text-sm');
                    promptEditButton.addEventListener('click', function() {
                        activePromptTargetTextarea = textarea; // Target this specific textarea
                        promptModal.style.display = 'block';
                        if (allPrompts.length === 0) {
                            fetchPrompts();
                        } else {
                            renderPrompts(allPrompts);
                        }
                        promptFilterInput.value = '';
                        promptFilterInput.focus();
                    });
                    rightButtonsDiv.appendChild(promptEditButton); // Add to right group

                    // New "Idea" button for the edit interface
                    const ideaEditButton = document.createElement('button');
                    ideaEditButton.textContent = 'Idea';
                    ideaEditButton.classList.add('bg-purple-500', 'hover:bg-purple-600', 'text-white', 'px-3', 'py-1', 'rounded', 'text-sm');
                    ideaEditButton.addEventListener('click', function() {
                        activePromptTargetTextarea = textarea; // Target this specific textarea
                        ideaModal.style.display = 'block';
                        if (allIdeas.length === 0) {
                            fetchIdeas();
                        } else {
                            renderIdeas(allIdeas);
                        }
                        ideaFilterInput.value = '';
                        ideaFilterInput.focus();
                    });
                    rightButtonsDiv.appendChild(ideaEditButton); // Add to right group

                    editControlsDiv.appendChild(leftButtonsDiv);
                    editControlsDiv.appendChild(rightButtonsDiv);

                    editingInterfaceDiv.appendChild(textarea);
                    editingInterfaceDiv.appendChild(editControlsDiv);

                    // Insert the editing interface: after roleSelect, before footerDiv
                    // messageDiv structure: roleSelect, contentP, footerDiv(iconsDiv, plusButtonDiv, navArrowsDiv)
                    // We want to insert it after roleSelect, and contentP is hidden.
                    // footerDiv contains iconsDiv, which is also hidden.
                    // So, insert before footerDiv.
                    messageDiv.insertBefore(editingInterfaceDiv, footerDiv);

                    // Initial height adjustment AFTER textarea is in the DOM
                    textarea.style.height = 'auto';
                    textarea.style.height = Math.max(textarea.scrollHeight + 5, minHeightPx) + 'px'; // Added 5px buffer
                });

                const deleteButton = document.createElement('button');
                deleteButton.innerHTML = 'üóëÔ∏è'; // Unicode for Delete
                deleteButton.title = 'Delete';
                deleteButton.classList.add('text-xs', 'hover:text-gray-300', 'focus:outline-none');

                deleteButton.addEventListener('click', function() {
                    const messageIdToDelete = messageDiv.dataset.messageId;
                    if (!messageIdToDelete) {
                        console.error('Message ID not found for deletion.');
                        alert('Cannot delete message: ID missing.');
                        return;
                    }

                    if (!currentChatId) {
                        console.error('Current chat ID not found for deletion.');
                        alert('Cannot delete message: Chat context missing.');
                        return;
                    }

                    if (window.confirm('Are you sure you want to delete this message and all its replies?')) {
                        fetch(`/api/chat/${currentChatId}/message/${messageIdToDelete}/delete/`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': '{{ csrf_token }}'
                            },
                        })
                        .then(response => {
                            if (!response.ok) {
                                return response.json().then(err => { throw new Error(err.error || `HTTP error! status: ${response.status}`) });
                            }
                            return response.json();
                        })
                        .then(data => {
                            console.log('Message deletion successful:', data.message);
                            // Re-fetch chat details to update UI
                            const activeChatListItem = document.querySelector('.chat-item.bg-blue-600');
                            if (activeChatListItem) {
                                activeChatListItem.click();
                            } else if (currentChatId) { // Fallback if active class is lost
                                const targetChatLink = document.querySelector(`.chat-link[data-chat-id="${currentChatId}"]`);
                                if (targetChatLink) {
                                    const targetChatItem = targetChatLink.closest('.chat-item');
                                    if (targetChatItem) targetChatItem.click();
                                }
                            }
                        })
                        .catch(error => {
                            console.error('Error deleting message:', error);
                            alert('Error deleting message: ' + error.message);
                        });
                    }
                });

                const addSiblingButton = document.createElement('button');
                addSiblingButton.innerHTML = '‚Ü™Ô∏è'; // Unicode for Add Sibling (Branch)
                addSiblingButton.title = 'Add Sibling';
                addSiblingButton.classList.add('text-xs', 'hover:text-gray-300', 'focus:outline-none');
                addSiblingButton.addEventListener('click', function() {
                    const sourceMessageId = messageDiv.dataset.messageId;
                    if (!currentChatId || !sourceMessageId) {
                        console.error('Chat ID or Source Message ID is missing for adding sibling.');
                        alert('Could not add sibling: Chat or Source Message ID missing.');
                        return;
                    }

                    fetch(`/api/chat/${currentChatId}/message/${sourceMessageId}/add_sibling/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': '{{ csrf_token }}'
                        },
                        // No body needed as the backend derives info from source_message_id
                    })
                    .then(response => {
                        if (!response.ok) {
                            return response.json().then(err => { throw new Error(err.error || `HTTP error! status: ${response.status}`) });
                        }
                        return response.json();
                    })
                    .then(data => {
                        console.log('Add sibling successful:', data.message);
                        // Re-fetch chat details to update UI
                        const activeChatListItem = document.querySelector('.chat-item.bg-blue-600');
                        if (activeChatListItem) {
                            activeChatListItem.click();
                        } else if (currentChatId) {
                            const targetChatLink = document.querySelector(`.chat-link[data-chat-id="${currentChatId}"]`);
                            if (targetChatLink) {
                                const targetChatItem = targetChatLink.closest('.chat-item');
                                if (targetChatItem) targetChatItem.click();
                            }
                        }
                    })
                    .catch(error => {
                        console.error('Error adding sibling message:', error);
                        alert('Error adding sibling: ' + error.message);
                    });
                });

                const regenerateButton = document.createElement('button');
                regenerateButton.innerHTML = 'üîÑ'; // Unicode for Regenerate
                regenerateButton.title = 'Regenerate';
                regenerateButton.classList.add('text-xs', 'hover:text-gray-300', 'focus:outline-none');
                regenerateButton.addEventListener('click', function() {
                    const currentMessageId = messageDiv.dataset.messageId;
                    if (!currentChatId || !currentMessageId) {
                        console.error('Chat ID or Current Message ID is missing for regenerate.');
                        alert('Could not regenerate: Chat or Message ID missing.');
                        return;
                    }
                    if (!chatSocket || chatSocket.readyState !== WebSocket.OPEN) {
                        alert('WebSocket is not connected. Please try selecting the chat again or refresh.');
                        return;
                    }
                    const selectedModelId = chatModelSelectEl.value;
                    if (!selectedModelId) {
                        alert('Please select an AI model.');
                        return;
                    }

                    // Lock UI before starting async operations
                    lockGlobalUIAfterGenerationStart();

                    // Step 1: Create a new sibling for the current message
                    fetch(`/api/chat/${currentChatId}/message/${currentMessageId}/add_sibling/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': '{{ csrf_token }}'
                        }
                    })
                    .then(response => {
                        if (!response.ok) {
                            return response.json().then(err => { throw new Error(err.error || `HTTP error! status: ${response.status}`) });
                        }
                        return response.json();
                    })
                    .then(siblingData => {
                        if (siblingData.status === 'success' && siblingData.new_message_id) {
                            const newlyCreatedSiblingId = siblingData.new_message_id;

                            // Refresh chat display to show the new empty sibling
                            const activeChatListItem = document.querySelector('.chat-item.bg-blue-600');
                            if (activeChatListItem) {
                                activeChatListItem.click(); // This re-fetches and re-renders
                            } else if (currentChatId) { // Fallback
                                const targetChatLink = document.querySelector(`.chat-link[data-chat-id="${currentChatId}"]`);
                                if (targetChatLink) targetChatLink.closest('.chat-item')?.click();
                            }
                            
                            // Wait for DOM update after re-render
                            setTimeout(() => {
                                const newSiblingElementProse = chatMessagesContainerEl.querySelector(`[data-message-id="${newlyCreatedSiblingId}"] .prose`);
                                if (newSiblingElementProse) {
                                    currentAssistantMessageId = newlyCreatedSiblingId;
                                    currentAssistantMessageContentEl = newSiblingElementProse;
                                    currentAssistantMessageContentEl.dataset.rawContent = ""; // Ensure it's empty
                                    currentAssistantMessageContentEl.innerHTML = "";
                                    
                                    chatSocket.send(JSON.stringify({
                                        type: 'generate_into_empty_message',
                                        target_message_id: newlyCreatedSiblingId,
                                        model_id: selectedModelId
                                    }));
                                    // UI locking is already active. WebSocket 'unlock_sidebar' will handle unlocking.
                                } else {
                                    console.error("Could not find new sibling element .prose in DOM after refresh for regeneration.");
                                    alert("Error preparing for regeneration. UI might be out of sync.");
                                    unlockGlobalUIAfterGenerationEnd(); // Unlock UI if we can't proceed
                                }
                            }, 300); // Adjusted timeout, might need tuning
                        } else {
                            alert('Error creating sibling message for regeneration: ' + (siblingData.error || 'Unknown error'));
                            unlockGlobalUIAfterGenerationEnd(); // Unlock UI on error
                        }
                    })
                    .catch(error => {
                        console.error('Error in add_sibling_message_api call for regeneration:', error);
                        alert('Error setting up for regeneration: ' + error.message);
                        unlockGlobalUIAfterGenerationEnd(); // Unlock UI on error
                    });
                });

                if (msg.id !== chatRootMessageId) {
                    // addSiblingButton is now added to plusButtonDiv
                    iconsDiv.appendChild(regenerateButton); // Add the regenerate button here
                }
                iconsDiv.appendChild(copyButton);
                iconsDiv.appendChild(editButton);

                // Conditionally add the "Clean Remove" button if not the root message
                if (msg.id !== chatRootMessageId) {
                    const cleanRemoveButton = document.createElement('button');
                    cleanRemoveButton.innerHTML = '‚úÇÔ∏è'; // Unicode for Scissors, or choose another
                    cleanRemoveButton.title = 'Remove (keep children)';
                    cleanRemoveButton.classList.add('text-xs', 'hover:text-gray-300', 'focus:outline-none');
                    cleanRemoveButton.addEventListener('click', function() {
                        const messageIdToCleanRemove = messageDiv.dataset.messageId;
                        if (!messageIdToCleanRemove || !currentChatId) {
                            alert('Cannot clean remove message: ID or Chat context missing.');
                            return;
                        }
                        if (window.confirm('Are you sure you want to remove this message and reparent its children? This action cannot be undone.')) {
                            fetch(`/api/chat/${currentChatId}/message/${messageIdToCleanRemove}/clean_remove/`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRFToken': '{{ csrf_token }}'
                                },
                            })
                            .then(response => {
                                if (!response.ok) {
                                    return response.json().then(err => { throw new Error(err.error || `HTTP error! status: ${response.status}`) });
                                }
                                return response.json();
                            })
                            .then(data => {
                                console.log('Message clean remove successful:', data.message);
                                // Re-fetch chat details to update UI
                                const activeChatListItem = document.querySelector('.chat-item.bg-blue-600');
                                if (activeChatListItem) {
                                    activeChatListItem.click();
                                } else if (currentChatId) {
                                    const targetChatLink = document.querySelector(`.chat-link[data-chat-id="${currentChatId}"]`);
                                    if (targetChatLink) {
                                        const targetChatItem = targetChatLink.closest('.chat-item');
                                        if (targetChatItem) targetChatItem.click();
                                    }
                                }
                            })
                            .catch(error => {
                                console.error('Error clean removing message:', error);
                                alert('Error clean removing message: ' + error.message);
                            });
                        }
                    });
                    iconsDiv.appendChild(cleanRemoveButton);
                }

                iconsDiv.appendChild(deleteButton); // Original delete button
                footerDiv.appendChild(iconsDiv);

                // Plus Icon (bottom-center, conditional)
                if (showPlusIcon) {
                    const plusButtonDiv = document.createElement('div');
                    plusButtonDiv.classList.add('absolute', 'bottom-0', 'left-1/2', '-translate-x-1/2', 'flex', 'items-center', 'space-x-1'); // Added flex, items-center, space-x-1

                    const plusButton = document.createElement('button');
                    plusButton.innerHTML = '‚ûï'; // Unicode for Plus
                    plusButton.title = 'Add message below';
                    plusButton.classList.add('bg-gray-500', 'text-white', 'rounded-full', 'w-5', 'h-5', 'flex', 'items-center', 'justify-center', 'text-xs', 'hover:bg-gray-400', 'focus:outline-none');
                    plusButtonDiv.appendChild(plusButton);

                    // Add the "Add Sibling" button next to the Plus button if it's not the root message
                    // if (msg.id !== chatRootMessageId) {
                        // addSiblingButton is defined earlier in the renderMessage function
                        // plusButtonDiv.appendChild(addSiblingButton);
                    // }

                    footerDiv.appendChild(plusButtonDiv);

                    // Event listener for the Plus button
                    plusButton.addEventListener('click', function() {
                        const parentMessageId = messageDiv.dataset.messageId; // ID of the message this '+' belongs to

                        if (!currentChatId || !parentMessageId) {
                            console.error('Chat ID or Parent Message ID is missing for adding child message.');
                            alert('Could not add message: Chat or Parent Message ID missing.');
                            return;
                        }

                        // Using a NEW endpoint for this specific child-adding logic
                        fetch(`/api/chat/${currentChatId}/message/${parentMessageId}/add_child_message/`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': '{{ csrf_token }}'
                            },
                            // Sending empty content, backend creates an empty message
                            body: JSON.stringify({ content: "" }) 
                        })
                        .then(response => {
                            if (!response.ok) {
                                return response.json().then(err => { throw new Error(err.error || `HTTP error! status: ${response.status}`) });
                            }
                            return response.json();
                        })
                        .then(data => {
                            console.log('Add child message successful:', data.message);
                            // Refresh the chat view (same logic as Save button)
                            const activeChatListItem = document.querySelector('.chat-item.bg-blue-600');
                            if (activeChatListItem) {
                                activeChatListItem.click();
                            } else if (currentChatId) {
                                const targetChatLink = document.querySelector(`.chat-link[data-chat-id="${currentChatId}"]`);
                                if (targetChatLink) {
                                    const targetChatItem = targetChatLink.closest('.chat-item');
                                    if (targetChatItem) targetChatItem.click();
                                }
                            }
                        })
                        .catch(error => {
                            console.error('Error adding child message:', error);
                            alert('Error adding child message: ' + error.message);
                        });
                    });
                }

                // Navigation Arrows for active siblings
                if (msg.is_active_sibling) {
                    const navArrowsDiv = document.createElement('div');
                    navArrowsDiv.classList.add('absolute', 'bottom-0', 'left-0', 'flex', 'space-x-1', 'items-center', 'h-5', 'message-sibling-nav'); // Added 'message-sibling-nav' class

                    const createArrowButton = (text, targetSiblingId, parentMsgId) => {
                        const arrowButton = document.createElement('button');
                        arrowButton.innerHTML = text; // e.g., '‚Üê' or '‚Üí'
                        arrowButton.title = text === '‚Üê' ? 'Previous message' : 'Next message';
                        arrowButton.classList.add('text-lg', 'hover:text-gray-300', 'focus:outline-none', 'px-1'); // Larger text for arrows
                        arrowButton.addEventListener('click', function(event) {
                            event.stopPropagation(); // Prevent other click handlers on messageDiv if any

                            if (!currentChatId || !parentMsgId || !targetSiblingId) {
                                console.error('Missing IDs for sibling navigation:', currentChatId, parentMsgId, targetSiblingId);
                                alert('Cannot navigate: missing information.');
                                return;
                            }
                            fetch(`/api/chat/${currentChatId}/set_active_child/`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRFToken': '{{ csrf_token }}'
                                },
                                body: JSON.stringify({
                                    parent_message_id: parentMsgId,
                                    child_to_activate_id: targetSiblingId
                                })
                            })
                            .then(response => {
                                if (!response.ok) {
                                    return response.json().then(err => { throw new Error(err.error || `HTTP error! status: ${response.status}`) });
                                }
                                return response.json();
                            })
                            .then(data => {
                                console.log('Active child set:', data.message);
                                // Re-fetch chat details to update UI
                                // Find the currently selected chat list item and click it to refresh
                                const activeChatListItem = document.querySelector('.chat-item.bg-blue-600');
                                if (activeChatListItem) {
                                    activeChatListItem.click();
                                } else if (currentChatId) { // Fallback if somehow the active class is lost
                                     const targetChatLink = document.querySelector(`.chat-link[data-chat-id="${currentChatId}"]`);
                                     if (targetChatLink) {
                                         const targetChatItem = targetChatLink.closest('.chat-item');
                                         if (targetChatItem) targetChatItem.click();
                                     }
                                }
                            })
                            .catch(error => {
                                console.error('Error setting active child:', error);
                                alert('Error navigating messages: ' + error.message);
                            });
                        });
                        return arrowButton;
                    };

                    const hasPrev = msg.previous_sibling_id !== null && msg.previous_sibling_id !== undefined;
                    const hasNext = msg.next_sibling_id !== null && msg.next_sibling_id !== undefined;

                    if (hasPrev) {
                        navArrowsDiv.appendChild(createArrowButton('‚Üê', msg.previous_sibling_id, msg.parent_id));
                    }
                    if (hasNext) {
                        navArrowsDiv.appendChild(createArrowButton('‚Üí', msg.next_sibling_id, msg.parent_id));
                    }

                    if (navArrowsDiv.hasChildNodes()) {
                        footerDiv.appendChild(navArrowsDiv);
                    }
                }

                messageDiv.appendChild(footerDiv);
                container.appendChild(messageDiv);
            }

            // Function to render message tree
            function renderMessageTree(nodesToProcess, container, counter, chatRootMessageId) { // Added chatRootMessageId
                nodesToProcess.forEach((currentNode, index) => {
                    // Plus icon is now shown for every message.
                    const showPlus = true;

                    renderMessage(currentNode, container, showPlus, counter.value, chatRootMessageId); // Pass chatRootMessageId
                    counter.value++;

                    if (currentNode.children && currentNode.children.length > 0) {
                        let childrenForNextLevel = [];
                        if (currentNode.active_child_id) {
                            childrenForNextLevel = currentNode.children.filter(child => child.id === currentNode.active_child_id);
                        } else {
                            // No explicit active_child_id.
                            // Check if there's an implicitly active child (e.g., a single child that is marked is_active_sibling by backend).
                            // The backend sets is_active_sibling if it's the active_child OR if it's the only child and no active_child is set.
                            const implicitlyActiveChild = currentNode.children.find(child => child.is_active_sibling === true);
                            if (implicitlyActiveChild) {
                                childrenForNextLevel = [implicitlyActiveChild];
                            } else {
                                // No explicit active_child_id and no implicitly active child (e.g., multiple children, none marked active by backend)
                                // Or if backend logic for is_active_sibling doesn't cover all desired "implicit" cases.
                                // For safety, if no active_child_id, we render no children unless one is marked is_active_sibling.
                                childrenForNextLevel = [];
                            }
                        }

                        if (childrenForNextLevel.length > 0) {
                            renderMessageTree(childrenForNextLevel, container, counter, chatRootMessageId); // Pass chatRootMessageId
                        }
                    }
                });
            }


            chatItems.forEach(item => {
                item.addEventListener('click', function (event) {
                    event.preventDefault();
                    const chatLink = this.querySelector('.chat-link');
                    if (!chatLink) return;

                    const chatIdFromLink = chatLink.dataset.chatId;
                    if (!chatIdFromLink) return;

                    currentChatId = chatIdFromLink; // Store the active chat ID

                    if (currentActiveChatLi) {
                        currentActiveChatLi.classList.remove('bg-blue-600', 'text-white');
                        currentActiveChatLi.classList.add('hover:bg-gray-700');
                        const oldChatActions = currentActiveChatLi.querySelector('.chat-actions');
                        if (oldChatActions) {
                            oldChatActions.classList.add('hidden');
                        }
                    }
                    this.classList.add('bg-blue-600', 'text-white');
                    this.classList.remove('hover:bg-gray-700');
                    const newChatActions = this.querySelector('.chat-actions');
                    if (newChatActions) {
                        newChatActions.classList.remove('hidden');
                    }
                    currentActiveChatLi = this;

                    fetch(`/api/chat/${currentChatId}/`)
                        .then(response => {
                            if (!response.ok) {
                                throw new Error(`HTTP error! status: ${response.status}`);
                            }
                            return response.json();
                        })
                        .then(data => {
                            // console.log("Chat details:", data);
                            // Set the selected model in the dropdown
                            if (data.ai_model_used_id) {
                                chatModelSelectEl.value = data.ai_model_used_id;
                            } else {
                                // If no specific model ID, try to select the first option or handle as needed
                                if (chatModelSelectEl.options.length > 0) {
                                    chatModelSelectEl.selectedIndex = 0;
                                }
                            }
                            chatModelTempEl.textContent = data.temperature || 'N/A';
                            currentChatRootMessageId = data.root_message_id; // Store root message ID
                            
                            chatMessagesContainerEl.innerHTML = ''; // Clear previous messages
                            if (data.messages && data.messages.length > 0) {
                                let messageCounter = { value: 0 };
                                renderMessageTree(data.messages, chatMessagesContainerEl, messageCounter, currentChatRootMessageId); // Pass currentChatRootMessageId
                            } else {
                                chatMessagesContainerEl.innerHTML = '<p class="text-gray-500 p-4">No messages in this chat yet.</p>';
                            }
                            chatMessagesContainerEl.scrollTop = chatMessagesContainerEl.scrollHeight;
                            
                            // Connect WebSocket for the newly selected/loaded chat
                            if (currentChatId) { // Ensure currentChatId is valid
                                connectWebSocket(currentChatId);
                                // requestCostEstimation(); // Moved to onopen for initial load
                            }
                        })
                        .catch(error => {
                            console.error('Error fetching chat details:', error);
                            if (chatSocket && chatSocket.readyState === WebSocket.OPEN) { 
                                chatSocket.close();
                            }
                            chatMessagesContainerEl.innerHTML = '<p class="text-red-400 p-4">Error loading chat. Please try again.</p>';
                            if (currentActiveChatLi) {
                                currentActiveChatLi.classList.remove('bg-blue-600', 'text-white');
                                currentActiveChatLi.classList.add('hover:bg-gray-700');
                    }
                });
            });

            // New Folder button functionality
            if (newFolderButton) {
                newFolderButton.addEventListener('click', function() {
                    const folderName = window.prompt("Enter the name for the new folder:");
                    if (folderName && folderName.trim() !== "") {
                        fetch(`/api/folder/create/`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': '{{ csrf_token }}'
                            },
                            body: JSON.stringify({ folder_name: folderName.trim() })
                        })
                        .then(response => {
                            if (!response.ok) {
                                return response.json().then(err => { throw new Error(err.error || `HTTP error! status: ${response.status}`) });
                            }
                            return response.json();
                        })
                        .then(data => {
                            if (data.status === 'success') {
                                //alert(data.message || 'Folder created successfully!');
                                window.location.reload(); // Reload to see the new folder
                            } else {
                                alert('Error creating folder: ' + (data.error || 'Unknown error'));
                            }
                        })
                        .catch(error => {
                            console.error('Error creating folder:', error);
                            alert('Error creating folder: ' + error.message);
                        });
                    }
                });
            }
            });

            // Automatically click the last active chat if it exists
            if (lastActiveChatIdFromDjango && lastActiveChatIdFromDjango !== '') {
                currentChatId = lastActiveChatIdFromDjango; // Set currentChatId if loading last active
                const targetChatLink = document.querySelector(`.chat-link[data-chat-id="${lastActiveChatIdFromDjango}"]`);
                if (targetChatLink) {
                    const targetChatItem = targetChatLink.closest('.chat-item');
                    if (targetChatItem) {
                        targetChatItem.click(); 
                    } else {
                        console.warn(`Could not find .chat-item for chat ID: ${lastActiveChatIdFromDjango}`);
                    }
                } else {
                    console.warn(`Could not find .chat-link for chat ID: ${lastActiveChatIdFromDjango}`);
                }
            }

            // Save button functionality (remains for non-streaming save)
            if (saveButton) {
                saveButton.addEventListener('click', function() {
                    const messageContent = messageInputTextarea.value.trim();
                    if (!messageContent) {
                        alert('Please type a message to save.');
                        return;
                    }
                    if (!currentChatId) {
                        alert('Please select a chat first.');
                        return;
                    }

                    // Find the newest message ID in the current chat display to use as parent
                    const allMessageElements = chatMessagesContainerEl.querySelectorAll('[data-message-id]');
                    let parentMessageId = null;
                    if (allMessageElements.length > 0) {
                        parentMessageId = allMessageElements[allMessageElements.length - 1].dataset.messageId;
                    } else {
                        console.warn("No messages found in container to set as parent. The backend might require a root message to exist.");
                        alert('Cannot save message: No parent message found in the current chat display.');
                        return;
                    }
                     if (!parentMessageId) {
                        alert('Cannot determine the parent message ID.');
                        return;
                    }


                    fetch(`/api/chat/${currentChatId}/add_message/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': '{{ csrf_token }}'
                        },
                        body: JSON.stringify({
                            message_content: messageContent,
                            parent_message_id: parentMessageId
                        })
                    })
                    .then(response => {
                        if (!response.ok) {
                            return response.json().then(err => { throw new Error(err.error || `HTTP error! status: ${response.status}`) });
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data.status === 'success' && data.message) {
                            messageInputTextarea.value = ''; 
                            const activeChatListItem = document.querySelector('.chat-item.bg-blue-600');
                            if (activeChatListItem) {
                                activeChatListItem.click(); 
                            } else if (currentChatId) { 
                                 const targetChatLink = document.querySelector(`.chat-link[data-chat-id="${currentChatId}"]`);
                                 if (targetChatLink) {
                                     const targetChatItem = targetChatLink.closest('.chat-item');
                                     if (targetChatItem) targetChatItem.click();
                                 }
                            }
                        } else {
                            alert('Error saving message: ' + (data.error || 'Unknown error'));
                        }
                    })
                    .catch(error => {
                        console.error('Error saving message:', error);
                        alert('Error saving message: ' + error.message);
                    });
                });
            } else {
                console.warn("Save button not found.");
            }

            // Generate button functionality (for streaming)
            if (generateButton) {
                generateButton.addEventListener('click', function() {
                    const userMessageContent = messageInputTextarea.value.trim();
                    if (!userMessageContent) {
                        alert('Please type a message to generate a response.');
                        return;
                    }
                    if (!currentChatId) {
                        alert('Please select a chat first.');
                        return;
                    }
                    if (!chatSocket || chatSocket.readyState !== WebSocket.OPEN) {
                        alert('WebSocket is not connected. Please try selecting the chat again or refresh.');
                        // Optionally, try to reconnect:
                        // if (currentChatId) connectWebSocket(currentChatId);
                        return;
                    }

                    const selectedModelId = chatModelSelectEl.value;
                    if (!selectedModelId) {
                        alert('Please select an AI model.');
                        return;
                    }

                    // Optimistically render the user's message
                    const tempUserMsgData = {
                        id: `temp-user-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`, // Unique temp ID
                        role: 'user',
                        content: userMessageContent,
                        // parent_id will be the last message in UI, or root if no messages.
                        // The consumer will determine the actual parent.
                    };
                    const messagesInUI = chatMessagesContainerEl.querySelectorAll('[data-message-id]');
                    // The renderMessage function will handle the temporary ID.
                    renderMessage(tempUserMsgData, chatMessagesContainerEl, true, messagesInUI.length, currentChatRootMessageId);
                    chatMessagesContainerEl.scrollTop = chatMessagesContainerEl.scrollHeight;


                    chatSocket.send(JSON.stringify({
                        type: 'start_generation',
                        user_message_content: userMessageContent,
                        model_id: selectedModelId
                        // temperature and max_tokens will be handled by consumer based on model/user settings
                    }));

                    messageInputTextarea.value = ''; // Clear textarea
                    messageInputTextarea.disabled = true;
                    this.disabled = true; // Disable Generate button
                    this.textContent = 'Generating...';
                    cancelGenerationButton.classList.remove('hidden'); // Show Cancel button
                    cancelGenerationButton.disabled = false;
                    cancelGenerationButton.textContent = 'Cancel';
                });
            }


            // Show/Hide folder actions on hover
            document.querySelectorAll('.folder-item-container summary').forEach(summaryElement => {
                const folderActions = summaryElement.querySelector('.folder-actions');
                if (folderActions) {
                    summaryElement.addEventListener('mouseenter', function() {
                        // Do not show actions if an input field is active within this summary (e.g., renaming folder)
                        if (!summaryElement.querySelector('.folder-name-input')) {
                            folderActions.classList.remove('hidden');
                        }
                    });
                    summaryElement.addEventListener('mouseleave', function() {
                        folderActions.classList.add('hidden');
                    });
                }
            });

            // Create new chat in folder functionality
            document.querySelectorAll('.create-chat-in-folder-button').forEach(button => {
                button.addEventListener('click', function(event) {
                    event.stopPropagation(); // Prevent the details/summary click
                    event.preventDefault(); // Prevent default button action if any
                    const folderName = this.closest('.folder-actions').dataset.folderName;
                    if (folderName) {
                        // Assuming 'create_new_chat' is the name of your URL pattern for creating a new chat
                        // And it can accept a 'folder' query parameter.
                        window.location.href = `{% url 'create_new_chat' %}?folder=${encodeURIComponent(folderName)}`;
                    }
                });
            });

            // Rename Folder functionality
            document.querySelectorAll('.rename-folder-button').forEach(button => {
                button.addEventListener('click', function(event) {
                    event.stopPropagation(); // Prevent details/summary click
                    event.preventDefault();

                    const folderActionsDiv = this.closest('.folder-actions');
                    const summaryElement = this.closest('summary');
                    const folderNameSpan = summaryElement.querySelector('.folder-name-display');
                    const originalFolderName = folderActionsDiv.dataset.folderName;

                    if (summaryElement.querySelector('.folder-name-input')) {
                        return; // Already in edit mode
                    }

                    folderNameSpan.style.display = 'none';
                    folderActionsDiv.classList.add('hidden'); // Hide actions while renaming

                    const inputElement = document.createElement('input');
                    inputElement.type = 'text';
                    inputElement.value = originalFolderName;
                    inputElement.classList.add('folder-name-input', 'bg-gray-700', 'text-white', 'p-1', 'rounded', 'text-sm', 'flex-grow', 'mr-2'); // Added mr-2 for spacing from potential other elements
                    
                    // Insert input before the folder-actions div, or at the start of summary if that's cleaner
                    summaryElement.insertBefore(inputElement, folderNameSpan.nextSibling); // Insert after the (now hidden) span
                    
                    inputElement.focus();
                    inputElement.select();

                    function revertFolderDisplay() {
                        if (summaryElement.contains(inputElement)) {
                            summaryElement.removeChild(inputElement);
                        }
                        folderNameSpan.style.display = '';
                        // folderActionsDiv.classList.remove('hidden'); // Re-showing actions is handled by mouseenter/leave
                    }

                    inputElement.addEventListener('keypress', function(e) {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            const newFolderName = inputElement.value.trim();
                            if (newFolderName && newFolderName !== originalFolderName) {
                                // API Call to rename folder
                                fetch(`/api/folder/rename/`, {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'X-CSRFToken': '{{ csrf_token }}'
                                    },
                                    body: JSON.stringify({
                                        old_folder_name: originalFolderName,
                                        new_folder_name: newFolderName
                                    })
                                })
                                .then(response => {
                                    if (!response.ok) {
                                        return response.json().then(err => { throw new Error(err.error || `HTTP error! status: ${response.status}`) });
                                    }
                                    return response.json();
                                })
                                .then(data => {
                                    if (data.status === 'success') {
                                        // Update UI: folder name, data-attribute, and potentially re-render part of the list or reload
                                        // For now, just update the display and data attribute. A full reload might be safer.
                                        folderNameSpan.textContent = newFolderName;
                                        folderActionsDiv.dataset.folderName = newFolderName;
                                        // Update folder name for all chats within this folder in the UI (if displayed)
                                        const folderDetailsContainer = summaryElement.closest('.folder-item-container');
                                        // This part is complex as it requires updating potentially many chat items if they store folder context
                                        // For simplicity, a page reload or re-fetching folder structure might be better after successful rename.
                                        // For now, we'll just update the name.
                                        // alert(data.message + " Please refresh the page to see all changes reflected."); // Temp
                                        revertFolderDisplay();
                                    } else {
                                        alert('Error renaming folder: ' + (data.error || 'Unknown error'));
                                        revertFolderDisplay();
                                    }
                                })
                                .catch(error => {
                                    console.error('Error renaming folder:', error);
                                    alert('Error renaming folder: ' + error.message);
                                    revertFolderDisplay();
                                });
                            } else {
                                revertFolderDisplay();
                            }
                        }
                    });

                    inputElement.addEventListener('blur', function() {
                        setTimeout(revertFolderDisplay, 150); // Delay to allow Enter to process
                    });

                    inputElement.addEventListener('keydown', function(e) {
                        if (e.key === 'Escape') {
                            revertFolderDisplay();
                        }
                    });
                });
            });

            // Delete Folder functionality
            document.querySelectorAll('.delete-folder-button').forEach(button => {
                button.addEventListener('click', function(event) {
                    event.stopPropagation(); // Prevent details/summary click
                    event.preventDefault();

                    const folderActionsDiv = this.closest('.folder-actions');
                    const folderName = folderActionsDiv.dataset.folderName;
                    const folderContainerElement = this.closest('.folder-item-container');


                    if (!folderName) {
                        alert('Error: Folder name not found.');
                        return;
                    }

                    if (window.confirm(`Are you sure you want to delete the folder "${folderName}"?`)) {
                        fetch(`/api/folder/delete/`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': '{{ csrf_token }}'
                            },
                            body: JSON.stringify({ folder_name: folderName })
                        })
                        .then(response => {
                            if (!response.ok) {
                                return response.json().then(err => { throw new Error(err.error || `HTTP error! status: ${response.status}`) });
                            }
                            return response.json();
                        })
                        .then(data => {
                            if (data.status === 'success') {
                                // Remove the folder from the UI.
                                // This might require a more robust way to update the list, e.g., re-fetching or page reload.
                                // For now, just remove the element.
                                if (folderContainerElement) {
                                    folderContainerElement.remove();
                                }
                                // alert(data.message + " Please refresh the page if items don't appear correctly in 'Other Chats'."); // Temp
                            } else {
                                alert('Error deleting folder: ' + (data.error || 'Unknown error'));
                            }
                        })
                        .catch(error => {
                            console.error('Error deleting folder:', error);
                            alert('Error deleting folder: ' + error.message);
                        });
                    }
                });
            });

            // Rename chat functionality
            document.querySelectorAll('.rename-chat-button').forEach(button => {
                button.addEventListener('click', function(event) {
                    event.stopPropagation(); // Prevent chat item click event
                    const chatItem = this.closest('.chat-item');
                    const chatLink = chatItem.querySelector('.chat-link');
                    const chatId = chatLink.dataset.chatId;
                    const originalFullTitle = chatItem.dataset.chatFullTitle;

                    // If an input is already there for this item, do nothing
                    if (chatItem.querySelector('.chat-title-input')) {
                        return;
                    }

                    chatLink.style.display = 'none';

                    const chatActionsDivForHiding = chatItem.querySelector('.chat-actions');
                    if (chatActionsDivForHiding) {
                        chatActionsDivForHiding.style.display = 'none';
                    }

                    const inputElement = document.createElement('input');
                    inputElement.type = 'text';
                    inputElement.value = originalFullTitle;
                    inputElement.classList.add('chat-title-input', 'bg-gray-700', 'text-white', 'p-1', 'rounded', 'text-sm', 'w-full', 'flex-grow'); // Added flex-grow
                    
                    // Insert input before the chat-actions div
                    const chatActionsDiv = chatItem.querySelector('.chat-actions');
                    chatItem.insertBefore(inputElement, chatActionsDiv);
                    
                    inputElement.focus();
                    inputElement.select();

                    function revertToDisplay() {
                        if (chatItem.contains(inputElement)) {
                            chatItem.removeChild(inputElement);
                        }
                        chatLink.style.display = '';

                        const chatActionsDivForRestoring = chatItem.querySelector('.chat-actions');
                        if (chatActionsDivForRestoring) {
                            // chat-actions are normally 'flex' when visible, and 'hidden' (display:none) otherwise.
                            // The 'hidden' class is managed by the main chat item click logic.
                            // If this chatItem is the currentActiveChatLi, it means its actions should be visible.
                            if (chatItem === currentActiveChatLi) {
                                chatActionsDivForRestoring.style.display = 'flex';
                            } else {
                                // If it's not the active chat, its actions should remain hidden.
                                // This case might be rare if rename is only allowed on active,
                                // but good for robustness.
                                chatActionsDivForRestoring.style.display = 'none';
                            }
                        }
                    }

                    inputElement.addEventListener('keypress', function(e) {
                        if (e.key === 'Enter') {
                            e.preventDefault(); // Prevent form submission if any
                            const newTitle = inputElement.value.trim();
                            if (newTitle && newTitle !== originalFullTitle) {
                                fetch(`/api/chat/${chatId}/rename_title/`, {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'X-CSRFToken': '{{ csrf_token }}'
                                    },
                                    body: JSON.stringify({ new_title: newTitle })
                                })
                                .then(response => {
                                    if (!response.ok) {
                                        return response.json().then(err => { throw new Error(err.error || `HTTP error! status: ${response.status}`) });
                                    }
                                    return response.json();
                                })
                                .then(data => {
                                    if (data.status === 'success') {
                                        chatLink.textContent = data.new_title//.substring(0, 60) + (data.new_title.length > 60 ? '...' : '');
                                        chatItem.dataset.chatFullTitle = data.new_title; // Update the full title
                                        revertToDisplay();
                                    } else {
                                        alert('Error renaming chat: ' + (data.error || 'Unknown error'));
                                        revertToDisplay(); // Revert on error
                                    }
                                })
                                .catch(error => {
                                    console.error('Error renaming chat:', error);
                                    alert('Error renaming chat: ' + error.message);
                                    revertToDisplay(); // Revert on error
                                });
                            } else {
                                revertToDisplay(); // No change or empty title, just revert
                            }
                        }
                    });

                    inputElement.addEventListener('blur', function() {
                        // Timeout to allow click on potential save button or other actions
                        // For now, direct revert as per plan
                        setTimeout(revertToDisplay, 100); // Small delay to handle Enter press before blur
                    });
                    
                    inputElement.addEventListener('keydown', function(e) {
                        if (e.key === 'Escape') {
                            revertToDisplay();
                        }
                    });
                });
            });

            // Delete chat functionality
            document.querySelectorAll('.delete-chat-button').forEach(button => {
                button.addEventListener('click', function(event) {
                    event.stopPropagation(); // Prevent chat item click event
                    const chatIdToDelete = this.dataset.chatId;
                    const chatItemElement = this.closest('.chat-item'); // Get the <li> element

                    if (!chatIdToDelete) {
                        alert('Error: Chat ID not found for deletion.');
                        return;
                    }

                    if (window.confirm('Are you sure you want to delete this chat and all its messages?')) {
                        fetch(`/api/chat/${chatIdToDelete}/delete/`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': '{{ csrf_token }}'
                            },
                        })
                        .then(response => {
                            if (!response.ok) {
                                return response.json().then(err => { throw new Error(err.error || `HTTP error! status: ${response.status}`) });
                            }
                            return response.json();
                        })
                        .then(data => {
                            if (data.status === 'success') {
                                console.log('Chat deletion successful:', data.message);
                                if (chatItemElement) {
                                    chatItemElement.remove();
                                }
                                // If the deleted chat was the active one, try to select the next newest chat
                                if (currentChatId === chatIdToDelete) {
                                    const remainingChatItems = document.querySelectorAll('.chat-item');
                                    if (remainingChatItems.length > 0) {
                                        // The first item in the NodeList will be the top-most visible chat,
                                        // which corresponds to the newest due to Django's ordering.
                                        remainingChatItems[0].click(); // Programmatically click the new chat item
                                    } else {
                                        // No chats left, clear the display
                                        chatMessagesContainerEl.innerHTML = '<p class="text-gray-500 p-4">No chats available. Create a new one!</p>';
                                        if (chatModelSelectEl.options.length > 0) chatModelSelectEl.selectedIndex = 0; // Reset dropdown
                                        chatModelTempEl.textContent = 'N/A';
                                        // chatSystemPromptEl.textContent = 'No system prompt set.';
                                        if (costEstimationDisplayEl) costEstimationDisplayEl.textContent = 'Input Tokens: 0, Est. Cost: $0.000000 (Note: This is an estimate)';
                                        currentChatId = null;
                                        currentActiveChatLi = null;
                                    }
                                }
                            } else {
                                alert('Error deleting chat: ' + (data.message || 'Unknown error'));
                            }
                        })
                        .catch(error => {
                            console.error('Error deleting chat:', error);
                            alert('Error deleting chat: ' + error.message);
                        });
                    }
                });
            });

            // Folder open/close state persistence
            document.querySelectorAll('details.folder-item-container').forEach(detailsElement => {
                detailsElement.addEventListener('toggle', function(event) {
                    const folderId = this.dataset.folderId;
                    if (!folderId) {
                        console.error('Folder ID not found for toggling state.');
                        return;
                    }
                    // The 'open' attribute is already changed by the browser at this point.
                    // We just need to inform the backend.
                    fetch(`/api/folder/${folderId}/toggle_open/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': '{{ csrf_token }}'
                        },
                        // No body needed, the backend toggles based on current state
                    })
                    .then(response => {
                        if (!response.ok) {
                            return response.json().then(err => { throw new Error(err.error || `HTTP error! status: ${response.status}`) });
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data.status === 'success') {
                            console.log(`Folder ${folderId} state updated to: ${data.is_open ? 'open' : 'closed'}`);
                        } else {
                            console.error('Error updating folder state:', data.error);
                            // Optionally, revert the toggle visually if the backend update fails,
                            // though this might be jarring for the user.
                            // For now, log the error.
                        }
                    })
                    .catch(error => {
                        console.error('Network error updating folder state:', error);
                    });
                });
            });

            // Drag and Drop Chat Functionality
            let draggedItem = null;

            document.querySelectorAll('.chat-item').forEach(item => {
                item.addEventListener('dragstart', function(event) {
                    draggedItem = event.target.closest('.chat-item');
                    event.dataTransfer.setData('text/plain', draggedItem.dataset.chatId);
                    setTimeout(() => { // Timeout to allow browser to capture the drag image
                        draggedItem.classList.add('is-dragging');
                    }, 0);
                });

                item.addEventListener('dragend', function(event) {
                    if (draggedItem) {
                        draggedItem.classList.remove('is-dragging');
                    }
                    draggedItem = null;
                    // Remove hover effect from all potential drop targets
                    document.querySelectorAll('.folder-drop-target').forEach(target => {
                        target.classList.remove('drop-hover');
                    });
                });
            });

            document.querySelectorAll('.folder-drop-target').forEach(target => {
                target.addEventListener('dragover', function(event) {
                    event.preventDefault(); // Necessary to allow dropping
                    target.classList.add('drop-hover');
                });

                target.addEventListener('dragleave', function(event) {
                    target.classList.remove('drop-hover');
                });

                target.addEventListener('drop', function(event) {
                    event.preventDefault();
                    target.classList.remove('drop-hover');
                    const chatId = event.dataTransfer.getData('text/plain');
                    const targetFolderId = target.dataset.folderId; // This will be folder ID or "other-chats-target"
                    
                    const itemToMove = draggedItem; // Capture the draggedItem at the moment of drop

                    if (!chatId || !itemToMove) {
                        console.error("Chat ID or dragged item not found at drop time.");
                        // If itemToMove is null here, it means dragend might have already cleared draggedItem.
                        // A page reload might be the safest recovery if itemToMove is null.
                        if (!itemToMove && chatId) { // If we have a chat ID but no item, something went wrong with drag state
                            console.warn("draggedItem was null but chatId present, reloading to reflect potential server-side changes.");
                            window.location.reload();
                        }
                        return;
                    }
                    
                    // Prevent dropping a chat into its current folder's list (visually it's already there)
                    const currentParentDropTarget = itemToMove.closest('.folder-drop-target');
                    if (currentParentDropTarget && currentParentDropTarget.dataset.folderId === targetFolderId) {
                        console.log("Chat is already in this folder.");
                        // Ensure is-dragging is removed if dragend didn't catch it due to early return
                        if(itemToMove) itemToMove.classList.remove('is-dragging');
                        return; // No action needed
                    }

                    fetch(`/api/chat/${chatId}/move_to_folder/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': '{{ csrf_token }}'
                        },
                        body: JSON.stringify({ target_folder_id: targetFolderId })
                    })
                    .then(response => {
                        if (!response.ok) {
                            return response.json().then(err => { throw new Error(err.error || `HTTP error! status: ${response.status}`) });
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data.status === 'success') {
                            // Move the chat item in the DOM
                            const targetList = target.querySelector('ul');
                            if (targetList) {
                                targetList.appendChild(itemToMove); // Use the captured itemToMove
                            } else {
                                // This case might happen if a folder is empty and has no <ul> yet,
                                // or if "Other Chats" is empty and its <ul> was removed or never created.
                                // For simplicity, we'll reload.
                                console.warn("Target list (ul) not found in the drop target, reloading page.");
                                window.location.reload();
                                return;
                            }
                            // If the chat was moved to "Other Chats", and "Other Chats" section wasn't visible,
                            // we might need to make it visible or just reload.
                            // For now, direct DOM move is attempted.
                            // A full page reload is a simpler way to ensure UI consistency after a move.
                            // window.location.reload(); // Uncomment for simpler update
                        } else {
                            alert('Error moving chat: ' + (data.error || 'Unknown error'));
                        }
                    })
                    .catch(error => {
                        console.error('Error moving chat:', error);
                        alert('Error moving chat: ' + error.message);
                    });
                });
            });

            // Event listener for chat model selection change
            if (chatModelSelectEl) {
                chatModelSelectEl.addEventListener('change', function() {
                    const selectedModelId = this.value;
                    if (!currentChatId) {
                        alert('Please select a chat first.');
                        // Optionally revert selection if no chat is active
                        // For now, we allow the change, but it won't be saved.
                        return;
                    }
                    if (!selectedModelId) {
                        alert('Invalid model selected.');
                        return;
                    }

                    fetch(`/api/chat/${currentChatId}/set_model/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': '{{ csrf_token }}'
                        },
                        body: JSON.stringify({ model_id: selectedModelId })
                    })
                    .then(response => {
                        if (!response.ok) {
                            return response.json().then(err => { throw new Error(err.error || `HTTP error! status: ${response.status}`) });
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data.status === 'success') {
                            console.log(`Chat model updated to ${data.new_model_name}`);
                            requestCostEstimation(); // Update cost estimation when model changes
                        } else {
                            alert('Error updating chat model: ' + (data.error || 'Unknown error'));
                        }
                    })
                    .catch(error => {
                        console.error('Error updating chat model:', error);
                        alert('Error updating chat model: ' + error.message);
                    });
                });
            }

            // Debounce function for input events
            function debounce(func, delay) {
                let timeout;
                return function(...args) {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(this, args), delay);
                };
            }

            // Function to request cost estimation
            function requestCostEstimation() {
                if (!costEstimationDisplayEl) {
                    console.log("Cost estimation: Display element not found.");
                    return;
                }

                // console.log("requestCostEstimation called. currentChatId:", currentChatId, "Socket State:", chatSocket ? chatSocket.readyState : "No socket", "Socket Open?", chatSocket ? (chatSocket.readyState === WebSocket.OPEN) : false);


                if (!chatSocket || chatSocket.readyState !== WebSocket.OPEN || !currentChatId) {
                    costEstimationDisplayEl.textContent = 'Estimating cost... (Waiting for connection or chat selection)';
                    console.log("Cost estimation: Socket not ready or no currentChatId. Socket state:", chatSocket ? chatSocket.readyState : "N/A", "currentChatId:", currentChatId);
                    return;
                }
                const currentInputContent = messageInputTextarea.value; // Get current text, do not trim
                const selectedModelId = chatModelSelectEl.value;
                // console.log("Selected Model ID for cost estimation:", selectedModelId);

                if (!selectedModelId) {
                    costEstimationDisplayEl.textContent = 'Select a model to estimate cost.';
                    console.log("Cost estimation: No model selected.");
                    return;
                }
                
                // Update UI immediately to indicate estimation is in progress
                costEstimationDisplayEl.textContent = 'Estimating cost...';
                // console.log("Cost estimation: Sending request to WebSocket.");

                chatSocket.send(JSON.stringify({
                    type: 'estimate_cost',
                    current_input_content: currentInputContent,
                    model_id: selectedModelId
                }));
            }

            // Attach debounced event listener to message input
            if (messageInputTextarea) {
                messageInputTextarea.addEventListener('input', debounce(requestCostEstimation, 750));

                messageInputTextarea.addEventListener('keydown', function(event) {
                    if (event.key === 'Enter' && !event.shiftKey) {
                        event.preventDefault(); // Prevent new line
                        if (generateButton) {
                            generateButton.click(); // Trigger generate button click
                        }
                    }
                    // If Shift + Enter, default behavior (new line) is allowed
                });
            }


            // Regenerate Title button functionality
            const regenTitleButton = document.getElementById('regen-title-button');

            // Clone Chat button functionality
            const cloneChatButton = document.getElementById('clone-chat-button');
            if (cloneChatButton) {
                cloneChatButton.addEventListener('click', function() {
                    if (!currentChatId) {
                        alert('Please select a chat to clone.');
                        return;
                    }
                    // Use currentActiveChatLi which is already maintained
                    const originalTitle = currentActiveChatLi ? currentActiveChatLi.dataset.chatFullTitle : null;

                    if (!originalTitle) {
                        // Fallback: try to find it if currentActiveChatLi is somehow not set but currentChatId is
                        const activeChatItem = document.querySelector(`.chat-item[data-chat-id="${currentChatId}"]`);
                        if (activeChatItem) {
                             originalTitle = activeChatItem.dataset.chatFullTitle;
                        }
                        if (!originalTitle) {
                            alert('Could not get current chat title to clone.');
                            return;
                        }
                    }

                    function generateNewChatName(currentTitle) {
                        const match = currentTitle.match(/(.*?)(\s+(\d+))?$/);
                        let baseName = currentTitle.trim(); // Default to trimmed current title
                        let number = 0;

                        if (match) {
                            // match[1] is the part before the number, match[3] is the number
                            let potentialBaseName = (match[1] || "").trim();
                            
                            if (match[3]) { // If there is a number
                                number = parseInt(match[3], 10);
                                if (potentialBaseName === "") { // Title was just " 123" or "123"
                                    baseName = "Chat"; // Default base name if original was just a number
                                } else {
                                    baseName = potentialBaseName;
                                }
                            } else { // No number found, use the whole title as base
                                baseName = currentTitle.trim();
                                if (baseName === "") baseName = "Chat"; // Handle empty original title
                            }
                        } else { // No match at all (e.g., empty string, though trim should handle)
                            baseName = "Chat"; // Default if title is problematic
                        }
                        return `${baseName} ${number + 1}`;
                    }
                    const newChatName = generateNewChatName(originalTitle);

                    fetch(`/api/chat/${currentChatId}/clone/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': '{{ csrf_token }}'
                        },
                        body: JSON.stringify({ new_chat_name: newChatName })
                    })
                    .then(response => {
                        if (!response.ok) {
                            return response.json().then(err => { 
                                throw new Error(err.error || `HTTP error ${response.status}`);
                            });
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data.status === 'success') {
                            // The backend will set the new chat as last_active_chat.
                            // Reloading the page will then pick it up.
                            window.location.reload();
                        } else {
                            alert('Error cloning chat: ' + (data.error || 'Unknown server error.'));
                        }
                    })
                    .catch(error => {
                        console.error('Error cloning chat:', error);
                        alert('Error cloning chat: ' + error.message);
                    });
                });
            }

            // Continue Chat button functionality
            const continueChatButton = document.getElementById('continue-chat-button');
            if (continueChatButton) {
                continueChatButton.addEventListener('click', function() {
                    if (!currentChatId) {
                        alert('Please select a chat to continue.');
                        return;
                    }
                    
                    let originalTitle = currentActiveChatLi ? currentActiveChatLi.dataset.chatFullTitle : null;
                    if (!originalTitle) {
                        const activeChatItem = document.querySelector(`.chat-item[data-chat-id="${currentChatId}"]`);
                        if (activeChatItem) {
                             originalTitle = activeChatItem.dataset.chatFullTitle;
                        }
                        if (!originalTitle) {
                            alert('Could not get current chat title to continue.');
                            return;
                        }
                    }

                    // Re-use the existing name generation logic from clone
                    function generateNewChatName(currentTitle) {
                        const match = currentTitle.match(/(.*?)(\s+(\d+))?$/);
                        let baseName = currentTitle.trim(); 
                        let number = 0;

                        if (match) {
                            let potentialBaseName = (match[1] || "").trim();
                            if (match[3]) { 
                                number = parseInt(match[3], 10);
                                if (potentialBaseName === "") { 
                                    baseName = "Chat"; 
                                } else {
                                    baseName = potentialBaseName;
                                }
                            } else { 
                                baseName = currentTitle.trim();
                                if (baseName === "") baseName = "Chat"; 
                            }
                        } else { 
                            baseName = "Chat"; 
                        }
                        return `${baseName} ${number + 1}`;
                    }
                    const newChatName = generateNewChatName(originalTitle);

                    fetch(`/api/chat/${currentChatId}/continue/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': '{{ csrf_token }}'
                        },
                        body: JSON.stringify({ new_chat_name: newChatName })
                    })
                    .then(response => {
                        if (!response.ok) {
                            return response.json().then(err => { 
                                throw new Error(err.error || `HTTP error ${response.status}`);
                            });
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data.status === 'success') {
                            window.location.reload(); // Reload to see the new chat
                        } else {
                            alert('Error continuing chat: ' + (data.error || 'Unknown server error.'));
                        }
                    })
                    .catch(error => {
                        console.error('Error continuing chat:', error);
                        alert('Error continuing chat: ' + error.message);
                    });
                });
            }

            // Helper functions for global UI lock/unlock during generation
            function setSiblingNavigationLock(isLocked) {
                const arrowButtons = document.querySelectorAll('.message-sibling-nav button'); // Use the new class
                arrowButtons.forEach(btn => {
                    btn.disabled = isLocked;
                    btn.style.opacity = isLocked ? '0.5' : '1';
                    // Optionally, more styling to indicate disabled state
                });
            }

            function setGlobalEditControlsLock(isLocked) {
                // Disable/enable all "Edit" (‚úèÔ∏è) buttons on messages
                const allEditButtons = chatMessagesContainerEl.querySelectorAll('button[title="Edit"]');
                allEditButtons.forEach(btn => {
                    btn.disabled = isLocked;
                    btn.style.opacity = isLocked ? '0.5' : '1';
                });

                // For any currently open edit interface, disable/enable its "Save" and "Generate" buttons
                const openEditInterfaces = chatMessagesContainerEl.querySelectorAll('.editing-interface');
                openEditInterfaces.forEach(editInterface => {
                    const saveBtn = editInterface.querySelector('button.bg-blue-500'); // Save button
                    const genBtn = editInterface.querySelector('button.bg-green-500');  // Generate button in edit menu
                    if (saveBtn) {
                        saveBtn.disabled = isLocked;
                        saveBtn.style.opacity = isLocked ? '0.5' : '1';
                    }
                    if (genBtn) {
                        genBtn.disabled = isLocked;
                        genBtn.style.opacity = isLocked ? '0.5' : '1';
                    }
                });
            }
            
            // Unified UI locking for generation start (called by 'lock_sidebar' WebSocket message)
            function lockGlobalUIAfterGenerationStart() {
                const sidebar = document.querySelector('aside');
                if (sidebar) {
                    sidebar.classList.add('sidebar-locked');
                }
                if (messageInputTextarea) messageInputTextarea.disabled = true;
                if (generateButton) { // Main generate button
                    generateButton.disabled = true;
                    generateButton.textContent = 'Generating...';
                }
                if (cancelGenerationButton) { // Main cancel button
                    cancelGenerationButton.classList.remove('hidden');
                    cancelGenerationButton.disabled = false;
                    cancelGenerationButton.textContent = 'Cancel';
                }
                setSiblingNavigationLock(true);
                setGlobalEditControlsLock(true);
                console.log('Global UI locked for generation.');
            }

            // Unified UI unlocking (called by 'unlock_sidebar' WebSocket message)
            function unlockGlobalUIAfterGenerationEnd() {
                const sidebar = document.querySelector('aside');
                if (sidebar) {
                    sidebar.classList.remove('sidebar-locked');
                }
                if (messageInputTextarea) messageInputTextarea.disabled = false;
                if (generateButton) { // Main generate button
                    generateButton.disabled = false;
                    generateButton.textContent = 'Generate';
                }
                if (cancelGenerationButton) { // Main cancel button
                    cancelGenerationButton.classList.add('hidden');
                    // cancelGenerationButton.disabled = true; // It's hidden, so disable state less critical until shown
                    cancelGenerationButton.textContent = 'Cancel'; // Reset text
                }
                setSiblingNavigationLock(false);
                setGlobalEditControlsLock(false);
                
                // Reset these critical state variables after generation attempt
                currentAssistantMessageId = null;
                currentAssistantMessageContentEl = null;
                console.log('Global UI unlocked.');
            }

            // Existing lockSidebar and unlockSidebar functions are now wrappers
            // These are called by WebSocket messages 'lock_sidebar' and 'unlock_sidebar'
            function lockSidebar() { 
                lockGlobalUIAfterGenerationStart();
            }

            function unlockSidebar() { 
                unlockGlobalUIAfterGenerationEnd();
            }

            if (regenTitleButton) {
                regenTitleButton.addEventListener('click', function() {
                    if (!currentChatId) {
                        alert('Please select a chat first to regenerate its title.');
                        return;
                    }

                    lockSidebar(); // Lock the sidebar

                    // Add some visual feedback that it's working
                    this.textContent = 'Regenerating...';
                    this.disabled = true;

                    fetch(`/api/chat/${currentChatId}/regenerate_title/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': '{{ csrf_token }}'
                        },
                        // No body needed for this request as per plan
                    })
                    .then(response => {
                        if (!response.ok) {
                            return response.json().then(err => { throw new Error(err.error || `HTTP error! status: ${response.status}`) });
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data.status === 'success' && data.new_title) {
                            // Update the chat title in the sidebar
                            const chatItemToUpdate = document.querySelector(`.chat-item[data-chat-id="${data.chat_id}"]`);
                            if (chatItemToUpdate) {
                                const chatLink = chatItemToUpdate.querySelector('.chat-link');
                                if (chatLink) {
                                    chatLink.textContent = data.new_title//.substring(0, 25) + (data.new_title.length > 25 ? '...' : '');
                                }
                                chatItemToUpdate.dataset.chatFullTitle = data.new_title;
                                // Optionally, display a success message to the user
                                // alert('Chat title regenerated successfully!');
                            } else {
                                console.warn(`Chat item with ID ${data.chat_id} not found in the sidebar to update title.`);
                            }
                        } else {
                            alert('Error regenerating title: ' + (data.error || 'Unknown error from server.'));
                        }
                    })
                    .catch(error => {
                        console.error('Error regenerating chat title:', error);
                        alert('Error regenerating title: ' + error.message);
                    })
                    .finally(() => {
                        this.textContent = 'Regen Title'; // Reset button text
                        this.disabled = false; // Re-enable button
                        unlockSidebar(); // Unlock the sidebar regardless of success or failure
                    });
                });
            }

            // --- Prompt Modal JavaScript ---
            if (openPromptModalButton) {
                openPromptModalButton.addEventListener('click', function() {
                    activePromptTargetTextarea = messageInputTextarea; // Set target to main input
                    promptModal.style.display = 'block';
                    if (allPrompts.length === 0) { // Fetch only if not already fetched
                        fetchPrompts();
                    } else {
                        renderPrompts(allPrompts); // Re-render if already fetched (e.g. to clear filter)
                    }
                    promptFilterInput.value = ''; // Clear filter on open
                    promptFilterInput.focus();
                });
            }

            if (closePromptModalButton) {
                closePromptModalButton.addEventListener('click', function() {
                    promptModal.style.display = 'none';
                });
            }

            // Close modal if user clicks outside of it
            window.addEventListener('click', function(event) {
                if (event.target == promptModal) {
                    promptModal.style.display = 'none';
                }
            });

            function fetchPrompts() {
                fetch('/api/prompts/')
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        allPrompts = data;
                        renderPrompts(allPrompts);
                    })
                    .catch(error => {
                        console.error('Error fetching prompts:', error);
                        promptListContainer.innerHTML = '<p class="text-red-400">Error loading prompts.</p>';
                    });
            }

            function renderPrompts(promptsToDisplay) {
                promptListContainer.innerHTML = ''; // Clear current list
                if (promptsToDisplay.length === 0) {
                    promptListContainer.innerHTML = '<p class="text-gray-400">No prompts found.</p>';
                    return;
                }
                promptsToDisplay.forEach(prompt => {
                    const promptDiv = document.createElement('div');
                    promptDiv.classList.add('prompt-item');
                    promptDiv.textContent = prompt.name;
                    promptDiv.dataset.promptText = prompt.prompt_text;
                    promptDiv.addEventListener('click', function() {
                        if (activePromptTargetTextarea) {
                            activePromptTargetTextarea.value = this.dataset.promptText;
                            // Dispatch an input event to trigger any auto-resize or other listeners
                            const inputEvent = new Event('input', { bubbles: true, cancelable: true });
                            activePromptTargetTextarea.dispatchEvent(inputEvent);
                            activePromptTargetTextarea.focus();
                        } else {
                            // Fallback to main input if target is somehow not set (should not happen with new logic)
                            messageInputTextarea.value = this.dataset.promptText;
                            const inputEvent = new Event('input', { bubbles: true, cancelable: true });
                            messageInputTextarea.dispatchEvent(inputEvent);
                            messageInputTextarea.focus();
                        }
                        promptModal.style.display = 'none';
                    });
                    promptListContainer.appendChild(promptDiv);
                });
            }

            if (promptFilterInput) {
                promptFilterInput.addEventListener('input', function() {
                    const filterText = this.value.toLowerCase();
                    const filteredPrompts = allPrompts.filter(p => p.name.toLowerCase().includes(filterText));
                    renderPrompts(filteredPrompts);
                });
            }
            // --- End of Prompt Modal JavaScript ---

            // --- Idea Modal JavaScript (Copied and modified from Prompt Modal JS) ---
            if (openIdeaModalButton) {
                openIdeaModalButton.addEventListener('click', function() {
                    activePromptTargetTextarea = messageInputTextarea; // Set target to main input
                    ideaModal.style.display = 'block';
                    if (allIdeas.length === 0) { // Fetch only if not already fetched
                        fetchIdeas();
                    } else {
                        renderIdeas(allIdeas); // Re-render if already fetched
                    }
                    ideaFilterInput.value = ''; // Clear filter on open
                    ideaFilterInput.focus();
                });
            }

            if (closeIdeaModalButton) {
                closeIdeaModalButton.addEventListener('click', function() {
                    ideaModal.style.display = 'none';
                });
            }

            // Close idea modal if user clicks outside of it
            window.addEventListener('click', function(event) {
                if (event.target == ideaModal) { // Check for ideaModal
                    ideaModal.style.display = 'none';
                }
            });

            function fetchIdeas() {
                fetch('/api/ideas/') // Changed URL to fetch ideas
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        allIdeas = data; // Store in allIdeas
                        renderIdeas(allIdeas); // Call renderIdeas
                    })
                    .catch(error => {
                        console.error('Error fetching ideas:', error);
                        ideaListContainer.innerHTML = '<p class="text-red-400">Error loading ideas.</p>'; // Update container
                    });
            }

            function renderIdeas(ideasToDisplay) {
                ideaListContainer.innerHTML = ''; // Clear current list in ideaListContainer
                if (ideasToDisplay.length === 0) {
                    ideaListContainer.innerHTML = '<p class="text-gray-400">No ideas found.</p>';
                    return;
                }
                ideasToDisplay.forEach(idea => { // Iterate ideas
                    const ideaDiv = document.createElement('div');
                    ideaDiv.classList.add('prompt-item'); // Can reuse 'prompt-item' class for styling if desired
                    ideaDiv.textContent = idea.name; // Display idea name
                    ideaDiv.dataset.ideaText = idea.idea_text; // Store idea_text in dataset
                    ideaDiv.addEventListener('click', function() {
                        const textarea = activePromptTargetTextarea || messageInputTextarea; // Ensure textarea is defined
                        const ideaTextToInsert = this.dataset.ideaText;
                        const startPos = textarea.selectionStart;
                        const endPos = textarea.selectionEnd;
                        
                        textarea.value = textarea.value.substring(0, startPos) + 
                                         ideaTextToInsert + 
                                         textarea.value.substring(endPos, textarea.value.length);
                        
                        // Move cursor to after the inserted text
                        const newCursorPos = startPos + ideaTextToInsert.length;
                        textarea.selectionStart = textarea.selectionEnd = newCursorPos;
                        
                        // Dispatch an input event to trigger any auto-resize or other listeners
                        const inputEvent = new Event('input', { bubbles: true, cancelable: true });
                        textarea.dispatchEvent(inputEvent);
                        textarea.focus();
                        
                        ideaModal.style.display = 'none'; // Hide ideaModal
                    });
                    ideaListContainer.appendChild(ideaDiv);
                });
            }

            if (ideaFilterInput) {
                ideaFilterInput.addEventListener('input', function() {
                    const filterText = this.value.toLowerCase();
                    const filteredIdeas = allIdeas.filter(i => i.name.toLowerCase().includes(filterText)); // Filter allIdeas
                    renderIdeas(filteredIdeas); // Call renderIdeas
                });
            }
            // --- End of Idea Modal JavaScript ---

            // --- Sidebar Search Functionality ---
            const searchInput = document.getElementById('sidebar-search');
            // const allChatItems = document.querySelectorAll('.chat-item'); // Already defined above, re-use
            const namedFolderDetailsElements = document.querySelectorAll('details.folder-item-container');
            const mainFoldersDetails = document.getElementById('main-folders-details');
            
            // Find "Other Chats" details element more robustly
            let otherChatsDetails = null;
            const allDetailsElements = document.querySelectorAll('aside .flex-1 details.group');
            allDetailsElements.forEach(detailsEl => {
                const summaryText = detailsEl.querySelector('summary')?.textContent.trim();
                if (summaryText && summaryText.includes("Other Chats")) {
                    otherChatsDetails = detailsEl;
                }
            });

            if (searchInput) {
                searchInput.addEventListener('input', function() {
                    const searchTerm = this.value.toLowerCase().trim();

                    // Filter chat items
                    chatItems.forEach(chatItem => {
                        const chatTitle = (chatItem.dataset.chatFullTitle || chatItem.querySelector('.chat-link')?.textContent || '').toLowerCase();
                        if (chatTitle.includes(searchTerm)) {
                            chatItem.style.display = '';
                        } else {
                            chatItem.style.display = 'none';
                        }
                    });

                    // Filter named folders
                    let anyNamedFolderVisible = false;
                    namedFolderDetailsElements.forEach(folderDetails => {
                        const folderNameSpan = folderDetails.querySelector('.folder-name-display');
                        const folderName = (folderNameSpan?.textContent || '').toLowerCase();
                        let hasVisibleChat = false;
                        folderDetails.querySelectorAll('.chat-item').forEach(chatInFolder => {
                            if (chatInFolder.style.display !== 'none') {
                                hasVisibleChat = true;
                            }
                        });

                        if (folderName.includes(searchTerm) || hasVisibleChat) {
                            folderDetails.style.display = '';
                            folderDetails.open = true;
                            anyNamedFolderVisible = true;
                        } else {
                            folderDetails.style.display = 'none';
                        }
                    });

                    // Filter "Other Chats" section
                    let otherChatsSectionVisible = false;
                    if (otherChatsDetails) {
                        const otherChatsTitle = (otherChatsDetails.querySelector('summary')?.textContent || '').toLowerCase();
                        let hasVisibleChatInOther = false;
                        otherChatsDetails.querySelectorAll('.chat-item').forEach(chatInOther => {
                            if (chatInOther.style.display !== 'none') {
                                hasVisibleChatInOther = true;
                            }
                        });

                        if (otherChatsTitle.includes(searchTerm) || hasVisibleChatInOther) {
                            otherChatsDetails.style.display = '';
                            otherChatsDetails.open = true;
                            otherChatsSectionVisible = true;
                        } else {
                            otherChatsDetails.style.display = 'none';
                        }
                    }
                    
                    // Filter main "Folders" details section
                    if (mainFoldersDetails) {
                        const mainFoldersTitle = (mainFoldersDetails.querySelector('summary > span.unselectable')?.textContent || '').toLowerCase();
                        if (mainFoldersTitle.includes(searchTerm) || anyNamedFolderVisible || (otherChatsDetails && otherChatsDetails.style.display !== 'none' && searchTerm === '')) { // Show if title matches, or any sub-folder is visible, or if search is empty and other chats was visible
                             mainFoldersDetails.style.display = '';
                             mainFoldersDetails.open = true;
                        } else if (!anyNamedFolderVisible && !(otherChatsDetails && otherChatsDetails.style.display !== 'none')) {
                             mainFoldersDetails.style.display = 'none';
                        }
                         // If search term is empty, ensure main folders section is visible if it has content
                        if (searchTerm === '') {
                            mainFoldersDetails.style.display = '';
                            // Restore open state for named folders if they were originally open and not empty
                            namedFolderDetailsElements.forEach(folder => {
                                const originallyOpen = folder.hasAttribute('data-originally-open'); // Need to set this attribute initially if we want to restore
                                const isEmpty = folder.querySelector('.chat-item') === null && folder.querySelector('p.text-xs.text-gray-500') !== null;
                                if (originallyOpen && !isEmpty) { // A more robust check for "originally open" would be needed
                                    // folder.open = true; // For now, just ensure it's visible
                                }
                            });
                            if (otherChatsDetails) {
                                // otherChatsDetails.open = true; // Similar logic for "Other Chats"
                            }
                        }
                    }
                     // If search term is empty, reset all to visible and default open states
                    if (searchTerm === '') {
                        chatItems.forEach(item => item.style.display = '');
                        namedFolderDetailsElements.forEach(folder => {
                            folder.style.display = '';
                            // folder.open = folder.hasAttribute('data-originally-open'); // Or some default
                        });
                        if (otherChatsDetails) {
                            otherChatsDetails.style.display = '';
                            // otherChatsDetails.open = true; // Default open
                        }
                        if (mainFoldersDetails) {
                            mainFoldersDetails.style.display = '';
                            mainFoldersDetails.open = true; // Default open
                        }
                    }
                });
            }
            // --- End of Sidebar Search Functionality ---
        });
    </script>
    {% endblock %}
</body>
</html>
