{% load static %}

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{% block title %}Best GPT Interface{% endblock %}</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        .unselectable {
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* IE10+/Edge */
            user-select: none; /* Standard */
        }
        .is-dragging {
            opacity: 0.5;
            background-color: #4a5568; /* gray-700 */
        }
        .drop-hover {
            background-color: #2d3748 !important; /* gray-800, using important to override potential inline styles or more specific selectors */
            border: 2px dashed #718096; /* gray-500 */
        }
    </style>
    {% block extra_head %}{% endblock %}
</head>
<body class="bg-gray-900 text-white h-screen flex">

    <!-- Sidebar -->
    <aside class="w-64 bg-gray-800 p-4 flex flex-col">
        <div class="flex items-center space-x-2 mb-4">
            <a href="{% url 'create_new_chat' %}" class="bg-gray-700 hover:bg-gray-600 text-white px-4 py-2 rounded text-sm text-center flex-grow">
                + New Chat
            </a>
            <button id="new-folder-button" title="New Folder" class="bg-gray-700 hover:bg-gray-600 text-white p-2 rounded">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path d="M2 6a2 2 0 012-2h5l2 2h5a2 2 0 012 2v6a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" />
                </svg>
            </button>
        </div>

        <div class="flex-1 overflow-y-auto"> <!-- Added overflow-y-auto for scrollable chat list -->
            <!-- Folder Dropdown -->
            <details class="group" open>
                <summary class="text-sm font-bold text-gray-400 mt-4 mb-2 px-2 cursor-pointer list-none flex items-center justify-between">
                    <span class="unselectable"><!-- <span class="group-open:rotate-90 inline-block mr-1 transition-transform duration-150 transform">‚ñ∂</span>--> Folders</span>
                </summary>
                <div class="ml-4"> <!-- Indent folder contents slightly more -->
                    {% for item in folder_structure %}
                        {% if item.name != "Other Chats" %}
                            <details class="group mt-2 folder-item-container" data-folder-id="{{ item.id }}" {% if item.is_open %}open{% endif %}> <!-- Wrapper for each folder, now a details element -->
                                <summary class="text-sm font-semibold text-gray-300 mb-1 px-2 cursor-pointer list-none flex items-center justify-between">
                                    <span class="folder-name-display flex-grow unselectable"><!-- <span class="group-open:rotate-90 inline-block mr-1 transition-transform duration-150 transform">‚ñ∂</span>--> {{ item.name }}</span>
                                    <div class="folder-actions flex items-center space-x-1 ml-2 hidden" data-folder-name="{{ item.name|escapejs }}" data-folder-id="{{ item.id }}">
                                        <button class="create-chat-in-folder-button text-gray-400 hover:text-white text-xs focus:outline-none" title="New Chat in Folder">‚ûï</button>
                                        <button class="rename-folder-button text-gray-400 hover:text-white text-xs focus:outline-none" title="Rename Folder">‚úèÔ∏è</button>
                                        <button class="delete-folder-button text-gray-400 hover:text-white text-xs focus:outline-none" title="Delete Folder">üóëÔ∏è</button>
                                    </div>
                                </summary>
                                <div class="ml-4 folder-drop-target" data-folder-id="{{ item.id }}"> <!-- Indent chats within each folder, ADDED folder-drop-target and data-folder-id -->
                                    {% if item.chats %}
                                        <ul class="space-y-1">
                                            {% for chat in item.chats %}
                                                <li class="text-white py-1 hover:bg-gray-700 rounded px-2 text-sm chat-item flex items-center justify-between" data-chat-id="{{ chat.id }}" data-chat-full-title="{{ chat.title }}" draggable="true">
                                                    <a href="#" class="chat-link flex-grow" data-chat-id="{{ chat.id }}">{{ chat.title|truncatechars:25 }}</a>
                                                    <div class="chat-actions flex space-x-2 ml-2 hidden">
                                                        <button class="rename-chat-button text-gray-400 hover:text-white text-xs focus:outline-none" title="Rename">‚úèÔ∏è</button>
                                                        <button class="delete-chat-button text-gray-400 hover:text-white text-xs focus:outline-none" title="Delete" data-chat-id="{{ chat.id }}">üóëÔ∏è</button>
                                                    </div>
                                                </li>
                                            {% endfor %}
                                        </ul>
                                    {% else %}
                                        <p class="text-xs text-gray-500 ml-2 px-2">No chats in this folder.</p>
                                    {% endif %}
                                </div>
                            </details>
                        {% endif %}
                    {% endfor %}
                </div>
            </details>

            <!-- Other Chats (Collapsible) -->
            {% for item in folder_structure %}
                {% if item.name == "Other Chats" %}
                    {% if item.chats %} <!-- Only show "Other Chats" section if it has chats -->
                    <details class="group" open> <!-- Default open -->
                        <summary class="text-sm font-bold text-gray-400 mt-4 mb-2 px-2 cursor-pointer list-none flex items-center unselectable">
                             <!-- <span class="group-open:rotate-90 inline-block mr-1 transition-transform duration-150 transform">‚ñ∂</span>--> {{ item.name }}
                        </summary>
                        <div class="ml-4 folder-drop-target" data-folder-id="other-chats-target"> <!-- Indent "Other Chats" contents, ADDED folder-drop-target and data-folder-id -->
                            <ul class="space-y-1">
                                {% for chat in item.chats %}
                                    <li class="text-white py-1 hover:bg-gray-700 rounded px-2 text-sm chat-item flex items-center justify-between" data-chat-id="{{ chat.id }}" data-chat-full-title="{{ chat.title }}" draggable="true">
                                        <a href="#" class="chat-link flex-grow" data-chat-id="{{ chat.id }}">{{ chat.title|truncatechars:25 }}</a>
                                        <div class="chat-actions flex space-x-2 ml-2 hidden">
                                            <button class="rename-chat-button text-gray-400 hover:text-white text-xs focus:outline-none" title="Rename">‚úèÔ∏è</button>
                                            <button class="delete-chat-button text-gray-400 hover:text-white text-xs focus:outline-none" title="Delete" data-chat-id="{{ chat.id }}">üóëÔ∏è</button>
                                        </div>
                                    </li>
                                {% endfor %}
                            </ul>
                        </div>
                    </details>
                    {% endif %}
                {% endif %}
            {% endfor %}
        </div>

        <div class="space-y-2 mt-4">
            <button class="text-sm text-gray-400 flex items-center">Hello, {{ user.username }}!</button>
            <!-- <button class="text-sm text-gray-400 flex">Manage Tags</button> Placeholder -->
            <!-- <button class="text-sm text-gray-400 flex">Import / Export</button> Placeholder -->
            <a href="{% url 'api_config' %}" class="text-sm text-gray-400 flex hover:text-white">API Configuration</a>
            <a href="{% url 'user_settings' %}" class="text-sm text-gray-400 flex hover:text-white">Settings</a>
        </div>
    </aside>

    <!-- Main Content -->
    <main class="flex-1 p-1 flex flex-col h-screen"> <!-- Added flex flex-col h-screen for layout -->
        {% block content %}
        <div class="bg-gray-800 p-4 rounded"> <!-- Added mb-4 for spacing -->
            <div class="flex items-center justify-between text-sm mb-2">
                <div>
                    Model: 
                    <select id="chat-model-select" class="bg-gray-700 text-white text-sm rounded p-1 focus:outline-none focus:ring-1 focus:ring-blue-500">
                        {% if available_models %}
                            {% for model in available_models %}
                                <option value="{{ model.id }}">{{ model.name }}</option>
                            {% endfor %}
                        {% else %}
                            <option value="">No models available</option>
                        {% endif %}
                    </select>
                </div>
                <span>Max Output: 64000</span> <!-- This might also become dynamic later -->
                <span>Temperature: <span id="chat-model-temp">0.8</span></span>
                <!-- <span>Top-p: 1</span>
                <span>Presence Penalty: 0</span>
                <span>Frequency Penalty: 0</span> -->
            </div>

            <!-- <div class="bg-gray-700 p-4 rounded mb-4">
                <span class="text-sm">System</span>
                <p id="chat-system-prompt">You are playing the role of a friendly and helpful chatbot.</p>
            </div> -->
        </div> <!-- Moved closing div for settings/system prompt block -->

        <!-- Chat Messages Area -->
        <div id="chat-messages-container" class="flex-grow overflow-y-auto bg-gray-750 p-4 rounded mb-4 space-y-2">
            <p class="text-gray-500">Select a chat to view messages.</p> 
        </div>

        <!-- Input Area -->
        <div class="bg-gray-800 p-4 rounded mt-auto"> <!-- mt-auto to push to bottom -->
            <div class="bg-gray-700 p-4 rounded flex items-start space-x-2">
                <!-- <div class="bg-red-500 px-2 py-1 rounded">User</div> -->
                <textarea class="w-full bg-gray-800 p-2 rounded text-white" rows="4" placeholder="Type a message or click / for prompts..."></textarea>
                <!-- Button column for Generate, Save, Prompt, Idea -->
                <div class="flex flex-col space-y-1">
                    <button class="bg-green-500 px-4 py-2 rounded w-full">Generate</button>
                    <button class="bg-gray-600 px-4 py-2 rounded w-full">Save</button>
                    <div class="flex space-x-1 mt-1">
                        <button class="bg-gray-600 px-3 py-1 rounded text-xs flex-grow">Prompt</button>
                        <button class="bg-gray-600 px-3 py-1 rounded text-xs flex-grow">Idea</button>
                    </div>
                </div>
            </div>
            <!-- The div that previously held Prompt and Idea buttons is removed by not including it here -->
            <div class="flex space-x-2 mt-4">
                <button class="bg-gray-700 px-3 py-1 rounded">Regen Title</button>
                <button class="bg-gray-700 px-3 py-1 rounded">Download Chat</button>
                <button class="bg-gray-700 px-3 py-1 rounded">Clone Chat</button>
                <button class="bg-gray-700 px-3 py-1 rounded">Continue</button>
            </div>
        </div> <!-- Closing div for input area -->
        {% endblock %}
    </main>
    {% block extra_js %}
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const chatItems = document.querySelectorAll('.chat-item');
            const chatModelSelectEl = document.getElementById('chat-model-select'); // Changed from chatModelNameEl
            const chatModelTempEl = document.getElementById('chat-model-temp');
            // const chatSystemPromptEl = document.getElementById('chat-system-prompt'); // System prompt display removed for now
            const chatMessagesContainerEl = document.getElementById('chat-messages-container');
            const messageInputTextarea = document.querySelector('textarea[placeholder="Type a message or click / for prompts..."]');
            const saveButton = document.querySelector('button.bg-gray-600.px-4.py-2.rounded.w-full'); // More specific selector if needed
            const newFolderButton = document.getElementById('new-folder-button');

            let currentActiveChatLi = null;
            let currentChatId = null; // To store the ID of the currently active chat
            const lastActiveChatIdFromDjango = '{{ last_active_chat_id|default_if_none:"" }}';

            // Function to render a single message
            function renderMessage(msg, container, showPlusIcon, messageIndex) {
                const messageDiv = document.createElement('div');
                messageDiv.classList.add('p-3', 'rounded-lg', 'break-words', 'mb-2', 'relative', 'text-gray-100'); // Added relative for icon positioning and default text color
                messageDiv.setAttribute('data-message-id', msg.id);

                // Role Dropdown
                const roleSelect = document.createElement('select');
                roleSelect.classList.add('bg-gray-500', 'text-white', 'text-xs', 'font-semibold', 'rounded', 'p-1', 'mb-1', 'mr-2', 'focus:outline-none', 'focus:ring-1', 'focus:ring-blue-400');
                const roles = ['User', 'Assistant', 'System'];
                roles.forEach(r => {
                    const option = document.createElement('option');
                    option.value = r.toLowerCase();
                    option.textContent = r;
                    if (msg.role && msg.role.toLowerCase() === r.toLowerCase()) {
                        option.selected = true;
                    } else if (!msg.role && r.toLowerCase() === 'assistant') { // Default to assistant if role is missing
                        option.selected = true;
                    }
                    roleSelect.appendChild(option);
                });

                // Event listener for role change
                roleSelect.addEventListener('change', function() {
                    const messageId = messageDiv.dataset.messageId;
                    const newRole = this.value;
                    if (!currentChatId || !messageId) {
                        console.error('Chat ID or Message ID is missing for role update.');
                        alert('Could not update role: Chat or Message ID missing.');
                        return;
                    }

                    fetch(`/api/chat/${currentChatId}/message/${messageId}/update_role/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': '{{ csrf_token }}' // Make sure CSRF token is available
                        },
                        body: JSON.stringify({ new_role: newRole })
                    })
                    .then(response => {
                        if (!response.ok) {
                            return response.json().then(err => { throw new Error(err.error || `HTTP error! status: ${response.status}`) });
                        }
                        return response.json();
                    })
                    .then(data => {
                        console.log('Role update successful:', data.message);
                        // Optionally, provide user feedback, e.g., a small temporary notification
                        // For now, just logging. The visual change is immediate due to dropdown selection.
                    })
                    .catch(error => {
                        console.error('Error updating message role:', error);
                        alert('Error updating role: ' + error.message);
                        // Optionally, revert the dropdown if the backend update fails
                        // For now, we leave it as is, assuming the user might retry or it's a transient issue.
                    });
                });

                const contentP = document.createElement('div'); // Changed to div to better accommodate block elements from Markdown
                contentP.classList.add('text-sm', 'prose', 'prose-sm', 'prose-invert', 'max-w-none', 'whitespace-pre-line'); // Added prose classes and whitespace-pre-line
                contentP.innerHTML = marked.parse(msg.content || '', { breaks: false, gfm: true }); // Use marked.parse, ensure gfm is on, breaks off.

                // Alternating grey backgrounds
                if (messageIndex % 2 === 0) {
                    messageDiv.classList.add('bg-gray-600');
                } else {
                    messageDiv.classList.add('bg-gray-700');
                }

                // Alignment based on role
                if (msg.role === 'user') {
                    messageDiv.classList.add('ml-auto');
                } else { // assistant or system roles
                    messageDiv.classList.add('mr-auto');
                }
                // Ensure roleSelect has consistent styling
                roleSelect.classList.add('bg-gray-500', 'text-white');


                messageDiv.appendChild(roleSelect);
                messageDiv.appendChild(contentP);

                // Footer for icons
                const footerDiv = document.createElement('div');
                footerDiv.classList.add('relative', 'h-5', 'mt-1'); // Height to contain icons, mt-1 for spacing

                // Action Icons (Copy, Edit, Delete) - bottom-right
                const iconsDiv = document.createElement('div');
                iconsDiv.classList.add('absolute', 'bottom-0', 'right-0', 'flex', 'space-x-2');

                const copyButton = document.createElement('button');
                copyButton.innerHTML = 'üìÑ'; // Unicode for Copy
                copyButton.title = 'Copy';
                copyButton.classList.add('text-xs', 'hover:text-gray-300', 'focus:outline-none');
                copyButton.addEventListener('click', function() {
                    // For Markdown, copying innerText might be more appropriate to get a plain text version
                    const textToCopy = contentP.innerText; 
                    navigator.clipboard.writeText(textToCopy)
                        .then(() => {
                            // Optional: Provide feedback to the user, e.g., change icon or show a tooltip
                            copyButton.innerHTML = '‚úÖ'; // Checkmark to indicate success
                            copyButton.title = 'Copied!';
                            setTimeout(() => {
                                copyButton.innerHTML = 'üìÑ'; // Revert to original icon
                                copyButton.title = 'Copy';
                            }, 1500); // Revert after 1.5 seconds
                        })
                        .catch(err => {
                            console.error('Failed to copy text: ', err);
                            alert('Failed to copy text. Your browser might not support this feature or permission was denied.');
                        });
                });

                const editButton = document.createElement('button');
                editButton.innerHTML = '‚úèÔ∏è'; // Unicode for Edit
                editButton.title = 'Edit';
                editButton.classList.add('text-xs', 'hover:text-gray-300', 'focus:outline-none');
                editButton.addEventListener('click', function() {
                    const messageId = messageDiv.dataset.messageId;
                    if (!messageId || !currentChatId) {
                        alert('Error: Message or Chat ID missing.');
                        return;
                    }

                    // Prevent multiple edit UIs
                    if (messageDiv.querySelector('.editing-interface')) {
                        return;
                    }

                    contentP.style.display = 'none';
                    iconsDiv.style.display = 'none'; // Hide the standard icons

                    const editingInterfaceDiv = document.createElement('div');
                    editingInterfaceDiv.classList.add('editing-interface', 'my-2'); // Added my-2 for spacing

                    const textarea = document.createElement('textarea');
                    // When editing, we should edit the raw Markdown source, not the rendered HTML's textContent
                    textarea.value = msg.content; // Assuming msg.content holds the raw markdown
                    textarea.classList.add('w-full', 'bg-gray-800', 'p-2', 'rounded', 'text-white', 'border', 'border-gray-600', 'focus:border-blue-500', 'focus:ring-1', 'focus:ring-blue-500');
                    textarea.rows = 3; // Initial rows, can grow
                    // Add a style to allow textarea to grow
                    textarea.style.minHeight = '6rem'; // equivalent to rows="3" roughly
                    textarea.style.resize = 'vertical'; // Allow vertical resize by user if browser supports
                    textarea.addEventListener('input', function () {
                        this.style.height = 'auto';
                        this.style.height = (this.scrollHeight) + 'px';
                    });


                    const editControlsDiv = document.createElement('div');
                    editControlsDiv.classList.add('flex', 'space-x-2', 'mt-2');

                    const saveEditButton = document.createElement('button');
                    saveEditButton.textContent = 'Save';
                    saveEditButton.classList.add('bg-blue-500', 'hover:bg-blue-600', 'text-white', 'px-3', 'py-1', 'rounded', 'text-sm');
                    saveEditButton.addEventListener('click', function() {
                        const newText = textarea.value;
                        fetch(`/api/chat/${currentChatId}/message/${messageId}/update_content/`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': '{{ csrf_token }}'
                            },
                            body: JSON.stringify({ new_content: newText })
                        })
                        .then(response => {
                            if (!response.ok) {
                                return response.json().then(err => { throw new Error(err.error || `HTTP error! status: ${response.status}`) });
                            }
                            return response.json();
                        })
                        .then(data => {
                            // Update the raw content store (msg.content) if possible, or re-fetch for consistency
                            msg.content = newText; // Update local msg object
                            contentP.innerHTML = marked.parse(newText, { breaks: false, gfm: true }); // Re-render Markdown, ensure gfm is on, breaks off.
                            // Restore UI
                            editingInterfaceDiv.remove();
                            contentP.style.display = '';
                            iconsDiv.style.display = 'flex'; // Assuming it was flex
                        })
                        .catch(error => {
                            console.error('Error updating message content:', error);
                            alert('Error saving message: ' + error.message);
                            // Optionally, restore UI even on error, or leave textarea
                            // For now, let's restore it to avoid getting stuck
                            editingInterfaceDiv.remove();
                            contentP.style.display = '';
                            iconsDiv.style.display = 'flex';
                        });
                    });

                    const generateButton = document.createElement('button');
                    generateButton.textContent = 'Generate';
                    generateButton.classList.add('bg-green-500', 'hover:bg-green-600', 'text-white', 'px-3', 'py-1', 'rounded', 'text-sm');
                    generateButton.addEventListener('click', function() {
                        console.log(`Generate clicked for message ID: ${messageId}`);
                        // Placeholder for future functionality
                    });

                    editControlsDiv.appendChild(saveEditButton);
                    editControlsDiv.appendChild(generateButton);

                    editingInterfaceDiv.appendChild(textarea);
                    editingInterfaceDiv.appendChild(editControlsDiv);

                    // Insert the editing interface: after roleSelect, before footerDiv
                    // messageDiv structure: roleSelect, contentP, footerDiv(iconsDiv, plusButtonDiv, navArrowsDiv)
                    // We want to insert it after roleSelect, and contentP is hidden.
                    // footerDiv contains iconsDiv, which is also hidden.
                    // So, insert before footerDiv.
                    messageDiv.insertBefore(editingInterfaceDiv, footerDiv);
                });

                const deleteButton = document.createElement('button');
                deleteButton.innerHTML = 'üóëÔ∏è'; // Unicode for Delete
                deleteButton.title = 'Delete';
                deleteButton.classList.add('text-xs', 'hover:text-gray-300', 'focus:outline-none');

                deleteButton.addEventListener('click', function() {
                    const messageIdToDelete = messageDiv.dataset.messageId;
                    if (!messageIdToDelete) {
                        console.error('Message ID not found for deletion.');
                        alert('Cannot delete message: ID missing.');
                        return;
                    }

                    if (!currentChatId) {
                        console.error('Current chat ID not found for deletion.');
                        alert('Cannot delete message: Chat context missing.');
                        return;
                    }

                    if (window.confirm('Are you sure you want to delete this message and all its replies?')) {
                        fetch(`/api/chat/${currentChatId}/message/${messageIdToDelete}/delete/`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': '{{ csrf_token }}'
                            },
                        })
                        .then(response => {
                            if (!response.ok) {
                                return response.json().then(err => { throw new Error(err.error || `HTTP error! status: ${response.status}`) });
                            }
                            return response.json();
                        })
                        .then(data => {
                            console.log('Message deletion successful:', data.message);
                            // Re-fetch chat details to update UI
                            const activeChatListItem = document.querySelector('.chat-item.bg-blue-600');
                            if (activeChatListItem) {
                                activeChatListItem.click();
                            } else if (currentChatId) { // Fallback if active class is lost
                                const targetChatLink = document.querySelector(`.chat-link[data-chat-id="${currentChatId}"]`);
                                if (targetChatLink) {
                                    const targetChatItem = targetChatLink.closest('.chat-item');
                                    if (targetChatItem) targetChatItem.click();
                                }
                            }
                        })
                        .catch(error => {
                            console.error('Error deleting message:', error);
                            alert('Error deleting message: ' + error.message);
                        });
                    }
                });

                const addSiblingButton = document.createElement('button');
                addSiblingButton.innerHTML = '‚Ü™Ô∏è'; // Unicode for Add Sibling (Branch)
                addSiblingButton.title = 'Add Sibling';
                addSiblingButton.classList.add('text-xs', 'hover:text-gray-300', 'focus:outline-none');
                addSiblingButton.addEventListener('click', function() {
                    const sourceMessageId = messageDiv.dataset.messageId;
                    if (!currentChatId || !sourceMessageId) {
                        console.error('Chat ID or Source Message ID is missing for adding sibling.');
                        alert('Could not add sibling: Chat or Source Message ID missing.');
                        return;
                    }

                    fetch(`/api/chat/${currentChatId}/message/${sourceMessageId}/add_sibling/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': '{{ csrf_token }}'
                        },
                        // No body needed as the backend derives info from source_message_id
                    })
                    .then(response => {
                        if (!response.ok) {
                            return response.json().then(err => { throw new Error(err.error || `HTTP error! status: ${response.status}`) });
                        }
                        return response.json();
                    })
                    .then(data => {
                        console.log('Add sibling successful:', data.message);
                        // Re-fetch chat details to update UI
                        const activeChatListItem = document.querySelector('.chat-item.bg-blue-600');
                        if (activeChatListItem) {
                            activeChatListItem.click();
                        } else if (currentChatId) {
                            const targetChatLink = document.querySelector(`.chat-link[data-chat-id="${currentChatId}"]`);
                            if (targetChatLink) {
                                const targetChatItem = targetChatLink.closest('.chat-item');
                                if (targetChatItem) targetChatItem.click();
                            }
                        }
                    })
                    .catch(error => {
                        console.error('Error adding sibling message:', error);
                        alert('Error adding sibling: ' + error.message);
                    });
                });

                iconsDiv.appendChild(addSiblingButton); // Add new button first
                iconsDiv.appendChild(copyButton);
                iconsDiv.appendChild(editButton);
                iconsDiv.appendChild(deleteButton);
                footerDiv.appendChild(iconsDiv);

                // Plus Icon (bottom-center, conditional)
                if (showPlusIcon) {
                    const plusButtonDiv = document.createElement('div');
                    plusButtonDiv.classList.add('absolute', 'bottom-0', 'left-1/2', '-translate-x-1/2');

                    const plusButton = document.createElement('button');
                    plusButton.innerHTML = '‚ûï'; // Unicode for Plus
                    plusButton.title = 'Add message below';
                    plusButton.classList.add('bg-gray-500', 'text-white', 'rounded-full', 'w-5', 'h-5', 'flex', 'items-center', 'justify-center', 'text-xs', 'hover:bg-gray-400', 'focus:outline-none');
                    plusButtonDiv.appendChild(plusButton);
                    footerDiv.appendChild(plusButtonDiv);
                }

                // Navigation Arrows for active siblings
                if (msg.is_active_sibling) {
                    const navArrowsDiv = document.createElement('div');
                    navArrowsDiv.classList.add('absolute', 'bottom-0', 'left-0', 'flex', 'space-x-1', 'items-center', 'h-5'); // Centered vertically with h-5

                    const createArrowButton = (text, targetSiblingId, parentMsgId) => {
                        const arrowButton = document.createElement('button');
                        arrowButton.innerHTML = text; // e.g., '‚Üê' or '‚Üí'
                        arrowButton.title = text === '‚Üê' ? 'Previous message' : 'Next message';
                        arrowButton.classList.add('text-lg', 'hover:text-gray-300', 'focus:outline-none', 'px-1'); // Larger text for arrows
                        arrowButton.addEventListener('click', function(event) {
                            event.stopPropagation(); // Prevent other click handlers on messageDiv if any

                            if (!currentChatId || !parentMsgId || !targetSiblingId) {
                                console.error('Missing IDs for sibling navigation:', currentChatId, parentMsgId, targetSiblingId);
                                alert('Cannot navigate: missing information.');
                                return;
                            }
                            fetch(`/api/chat/${currentChatId}/set_active_child/`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRFToken': '{{ csrf_token }}'
                                },
                                body: JSON.stringify({
                                    parent_message_id: parentMsgId,
                                    child_to_activate_id: targetSiblingId
                                })
                            })
                            .then(response => {
                                if (!response.ok) {
                                    return response.json().then(err => { throw new Error(err.error || `HTTP error! status: ${response.status}`) });
                                }
                                return response.json();
                            })
                            .then(data => {
                                console.log('Active child set:', data.message);
                                // Re-fetch chat details to update UI
                                // Find the currently selected chat list item and click it to refresh
                                const activeChatListItem = document.querySelector('.chat-item.bg-blue-600');
                                if (activeChatListItem) {
                                    activeChatListItem.click();
                                } else if (currentChatId) { // Fallback if somehow the active class is lost
                                     const targetChatLink = document.querySelector(`.chat-link[data-chat-id="${currentChatId}"]`);
                                     if (targetChatLink) {
                                         const targetChatItem = targetChatLink.closest('.chat-item');
                                         if (targetChatItem) targetChatItem.click();
                                     }
                                }
                            })
                            .catch(error => {
                                console.error('Error setting active child:', error);
                                alert('Error navigating messages: ' + error.message);
                            });
                        });
                        return arrowButton;
                    };

                    const hasPrev = msg.previous_sibling_id !== null && msg.previous_sibling_id !== undefined;
                    const hasNext = msg.next_sibling_id !== null && msg.next_sibling_id !== undefined;

                    if (hasPrev) {
                        navArrowsDiv.appendChild(createArrowButton('‚Üê', msg.previous_sibling_id, msg.parent_id));
                    }
                    if (hasNext) {
                        navArrowsDiv.appendChild(createArrowButton('‚Üí', msg.next_sibling_id, msg.parent_id));
                    }

                    if (navArrowsDiv.hasChildNodes()) {
                        footerDiv.appendChild(navArrowsDiv);
                    }
                }

                messageDiv.appendChild(footerDiv);
                container.appendChild(messageDiv);
            }

            // Function to render message tree
            function renderMessageTree(nodesToProcess, container, counter) {
                nodesToProcess.forEach((currentNode, index) => {
                    // Determine if the plus icon should be shown for adding a message after this one
                    let showPlus = false;
                    // The original logic for 'showPlus' is about adding a message *below* the current one,
                    // or as a sibling if it's not the last.
                    // This seems reasonable to keep as is, as it relates to the *potential* to add,
                    // not the display of existing children.
                    if ((currentNode.children && currentNode.children.length > 0) || index < nodesToProcess.length - 1) {
                        showPlus = true;
                    }

                    renderMessage(currentNode, container, showPlus, counter.value); // Render the currentNode
                    counter.value++;

                    if (currentNode.children && currentNode.children.length > 0) {
                        let childrenForNextLevel = [];
                        if (currentNode.active_child_id) {
                            childrenForNextLevel = currentNode.children.filter(child => child.id === currentNode.active_child_id);
                        } else {
                            // No explicit active_child_id.
                            // Check if there's an implicitly active child (e.g., a single child that is marked is_active_sibling by backend).
                            // The backend sets is_active_sibling if it's the active_child OR if it's the only child and no active_child is set.
                            const implicitlyActiveChild = currentNode.children.find(child => child.is_active_sibling === true);
                            if (implicitlyActiveChild) {
                                childrenForNextLevel = [implicitlyActiveChild];
                            } else {
                                // No explicit active_child_id and no implicitly active child (e.g., multiple children, none marked active by backend)
                                // Or if backend logic for is_active_sibling doesn't cover all desired "implicit" cases.
                                // For safety, if no active_child_id, we render no children unless one is marked is_active_sibling.
                                childrenForNextLevel = [];
                            }
                        }

                        if (childrenForNextLevel.length > 0) {
                            renderMessageTree(childrenForNextLevel, container, counter);
                        }
                    }
                });
            }


            chatItems.forEach(item => {
                item.addEventListener('click', function (event) {
                    event.preventDefault();
                    const chatLink = this.querySelector('.chat-link');
                    if (!chatLink) return;

                    const chatIdFromLink = chatLink.dataset.chatId;
                    if (!chatIdFromLink) return;

                    currentChatId = chatIdFromLink; // Store the active chat ID

                    if (currentActiveChatLi) {
                        currentActiveChatLi.classList.remove('bg-blue-600', 'text-white');
                        currentActiveChatLi.classList.add('hover:bg-gray-700');
                        const oldChatActions = currentActiveChatLi.querySelector('.chat-actions');
                        if (oldChatActions) {
                            oldChatActions.classList.add('hidden');
                        }
                    }
                    this.classList.add('bg-blue-600', 'text-white');
                    this.classList.remove('hover:bg-gray-700');
                    const newChatActions = this.querySelector('.chat-actions');
                    if (newChatActions) {
                        newChatActions.classList.remove('hidden');
                    }
                    currentActiveChatLi = this;

                    fetch(`/api/chat/${currentChatId}/`)
                        .then(response => {
                            if (!response.ok) {
                                throw new Error(`HTTP error! status: ${response.status}`);
                            }
                            return response.json();
                        })
                        .then(data => {
                            console.log("Chat details:", data);
                            // Set the selected model in the dropdown
                            if (data.ai_model_used_id) {
                                chatModelSelectEl.value = data.ai_model_used_id;
                            } else {
                                // If no specific model ID, try to select the first option or handle as needed
                                if (chatModelSelectEl.options.length > 0) {
                                    chatModelSelectEl.selectedIndex = 0; 
                                }
                            }
                            chatModelTempEl.textContent = data.temperature || 'N/A';
                            // chatSystemPromptEl.textContent = data.system_prompt || 'No system prompt set.';
                            
                            chatMessagesContainerEl.innerHTML = ''; // Clear previous messages
                            if (data.messages && data.messages.length > 0) {
                                let messageCounter = { value: 0 };
                                renderMessageTree(data.messages, chatMessagesContainerEl, messageCounter);
                            } else {
                                chatMessagesContainerEl.innerHTML = '<p class="text-gray-500 p-4">No messages in this chat yet.</p>';
                            }
                            chatMessagesContainerEl.scrollTop = chatMessagesContainerEl.scrollHeight;
                        })
                        .catch(error => {
                            console.error('Error fetching chat details:', error);
                            chatMessagesContainerEl.innerHTML = '<p class="text-red-400 p-4">Error loading chat. Please try again.</p>';
                            if (currentActiveChatLi) {
                                currentActiveChatLi.classList.remove('bg-blue-600', 'text-white');
                                currentActiveChatLi.classList.add('hover:bg-gray-700');
                    }
                });
            });

            // New Folder button functionality
            if (newFolderButton) {
                newFolderButton.addEventListener('click', function() {
                    const folderName = window.prompt("Enter the name for the new folder:");
                    if (folderName && folderName.trim() !== "") {
                        fetch(`/api/folder/create/`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': '{{ csrf_token }}'
                            },
                            body: JSON.stringify({ folder_name: folderName.trim() })
                        })
                        .then(response => {
                            if (!response.ok) {
                                return response.json().then(err => { throw new Error(err.error || `HTTP error! status: ${response.status}`) });
                            }
                            return response.json();
                        })
                        .then(data => {
                            if (data.status === 'success') {
                                //alert(data.message || 'Folder created successfully!');
                                window.location.reload(); // Reload to see the new folder
                            } else {
                                alert('Error creating folder: ' + (data.error || 'Unknown error'));
                            }
                        })
                        .catch(error => {
                            console.error('Error creating folder:', error);
                            alert('Error creating folder: ' + error.message);
                        });
                    }
                });
            }
            });

            // Automatically click the last active chat if it exists
            if (lastActiveChatIdFromDjango && lastActiveChatIdFromDjango !== '') {
                currentChatId = lastActiveChatIdFromDjango; // Set currentChatId if loading last active
                const targetChatLink = document.querySelector(`.chat-link[data-chat-id="${lastActiveChatIdFromDjango}"]`);
                if (targetChatLink) {
                    const targetChatItem = targetChatLink.closest('.chat-item');
                    if (targetChatItem) {
                        targetChatItem.click(); 
                    } else {
                        console.warn(`Could not find .chat-item for chat ID: ${lastActiveChatIdFromDjango}`);
                    }
                } else {
                    console.warn(`Could not find .chat-link for chat ID: ${lastActiveChatIdFromDjango}`);
                }
            }

            // Save button functionality
            if (saveButton) {
                saveButton.addEventListener('click', function() {
                    const messageContent = messageInputTextarea.value.trim();
                    if (!messageContent) {
                        alert('Please type a message to save.');
                        return;
                    }
                    if (!currentChatId) {
                        alert('Please select a chat first.');
                        return;
                    }

                    // Find the newest message ID in the current chat display to use as parent
                    const allMessageElements = chatMessagesContainerEl.querySelectorAll('[data-message-id]');
                    let parentMessageId = null;
                    if (allMessageElements.length > 0) {
                        parentMessageId = allMessageElements[allMessageElements.length - 1].dataset.messageId;
                    } else {
                        console.warn("No messages found in container to set as parent. The backend might require a root message to exist.");
                        alert('Cannot save message: No parent message found in the current chat display.');
                        return;
                    }
                     if (!parentMessageId) {
                        alert('Cannot determine the parent message ID.');
                        return;
                    }


                    fetch(`/api/chat/${currentChatId}/add_message/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': '{{ csrf_token }}'
                        },
                        body: JSON.stringify({
                            message_content: messageContent,
                            parent_message_id: parentMessageId
                        })
                    })
                    .then(response => {
                        if (!response.ok) {
                            return response.json().then(err => { throw new Error(err.error || `HTTP error! status: ${response.status}`) });
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data.status === 'success' && data.message) {
                            messageInputTextarea.value = ''; 
                            const activeChatListItem = document.querySelector('.chat-item.bg-blue-600');
                            if (activeChatListItem) {
                                activeChatListItem.click(); 
                            } else if (currentChatId) { 
                                 const targetChatLink = document.querySelector(`.chat-link[data-chat-id="${currentChatId}"]`);
                                 if (targetChatLink) {
                                     const targetChatItem = targetChatLink.closest('.chat-item');
                                     if (targetChatItem) targetChatItem.click();
                                 }
                            }
                        } else {
                            alert('Error saving message: ' + (data.error || 'Unknown error'));
                        }
                    })
                    .catch(error => {
                        console.error('Error saving message:', error);
                        alert('Error saving message: ' + error.message);
                    });
                });
            } else {
                console.warn("Save button not found.");
            }

            // Show/Hide folder actions on hover
            document.querySelectorAll('.folder-item-container summary').forEach(summaryElement => {
                const folderActions = summaryElement.querySelector('.folder-actions');
                if (folderActions) {
                    summaryElement.addEventListener('mouseenter', function() {
                        // Do not show actions if an input field is active within this summary (e.g., renaming folder)
                        if (!summaryElement.querySelector('.folder-name-input')) {
                            folderActions.classList.remove('hidden');
                        }
                    });
                    summaryElement.addEventListener('mouseleave', function() {
                        folderActions.classList.add('hidden');
                    });
                }
            });

            // Create new chat in folder functionality
            document.querySelectorAll('.create-chat-in-folder-button').forEach(button => {
                button.addEventListener('click', function(event) {
                    event.stopPropagation(); // Prevent the details/summary click
                    event.preventDefault(); // Prevent default button action if any
                    const folderName = this.closest('.folder-actions').dataset.folderName;
                    if (folderName) {
                        // Assuming 'create_new_chat' is the name of your URL pattern for creating a new chat
                        // And it can accept a 'folder' query parameter.
                        window.location.href = `{% url 'create_new_chat' %}?folder=${encodeURIComponent(folderName)}`;
                    }
                });
            });

            // Rename Folder functionality
            document.querySelectorAll('.rename-folder-button').forEach(button => {
                button.addEventListener('click', function(event) {
                    event.stopPropagation(); // Prevent details/summary click
                    event.preventDefault();

                    const folderActionsDiv = this.closest('.folder-actions');
                    const summaryElement = this.closest('summary');
                    const folderNameSpan = summaryElement.querySelector('.folder-name-display');
                    const originalFolderName = folderActionsDiv.dataset.folderName;

                    if (summaryElement.querySelector('.folder-name-input')) {
                        return; // Already in edit mode
                    }

                    folderNameSpan.style.display = 'none';
                    folderActionsDiv.classList.add('hidden'); // Hide actions while renaming

                    const inputElement = document.createElement('input');
                    inputElement.type = 'text';
                    inputElement.value = originalFolderName;
                    inputElement.classList.add('folder-name-input', 'bg-gray-700', 'text-white', 'p-1', 'rounded', 'text-sm', 'flex-grow', 'mr-2'); // Added mr-2 for spacing from potential other elements
                    
                    // Insert input before the folder-actions div, or at the start of summary if that's cleaner
                    summaryElement.insertBefore(inputElement, folderNameSpan.nextSibling); // Insert after the (now hidden) span
                    
                    inputElement.focus();
                    inputElement.select();

                    function revertFolderDisplay() {
                        if (summaryElement.contains(inputElement)) {
                            summaryElement.removeChild(inputElement);
                        }
                        folderNameSpan.style.display = '';
                        // folderActionsDiv.classList.remove('hidden'); // Re-showing actions is handled by mouseenter/leave
                    }

                    inputElement.addEventListener('keypress', function(e) {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            const newFolderName = inputElement.value.trim();
                            if (newFolderName && newFolderName !== originalFolderName) {
                                // API Call to rename folder
                                fetch(`/api/folder/rename/`, {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'X-CSRFToken': '{{ csrf_token }}'
                                    },
                                    body: JSON.stringify({
                                        old_folder_name: originalFolderName,
                                        new_folder_name: newFolderName
                                    })
                                })
                                .then(response => {
                                    if (!response.ok) {
                                        return response.json().then(err => { throw new Error(err.error || `HTTP error! status: ${response.status}`) });
                                    }
                                    return response.json();
                                })
                                .then(data => {
                                    if (data.status === 'success') {
                                        // Update UI: folder name, data-attribute, and potentially re-render part of the list or reload
                                        // For now, just update the display and data attribute. A full reload might be safer.
                                        folderNameSpan.textContent = newFolderName;
                                        folderActionsDiv.dataset.folderName = newFolderName;
                                        // Update folder name for all chats within this folder in the UI (if displayed)
                                        const folderDetailsContainer = summaryElement.closest('.folder-item-container');
                                        // This part is complex as it requires updating potentially many chat items if they store folder context
                                        // For simplicity, a page reload or re-fetching folder structure might be better after successful rename.
                                        // For now, we'll just update the name.
                                        // alert(data.message + " Please refresh the page to see all changes reflected."); // Temp
                                        revertFolderDisplay();
                                    } else {
                                        alert('Error renaming folder: ' + (data.error || 'Unknown error'));
                                        revertFolderDisplay();
                                    }
                                })
                                .catch(error => {
                                    console.error('Error renaming folder:', error);
                                    alert('Error renaming folder: ' + error.message);
                                    revertFolderDisplay();
                                });
                            } else {
                                revertFolderDisplay();
                            }
                        }
                    });

                    inputElement.addEventListener('blur', function() {
                        setTimeout(revertFolderDisplay, 150); // Delay to allow Enter to process
                    });

                    inputElement.addEventListener('keydown', function(e) {
                        if (e.key === 'Escape') {
                            revertFolderDisplay();
                        }
                    });
                });
            });

            // Delete Folder functionality
            document.querySelectorAll('.delete-folder-button').forEach(button => {
                button.addEventListener('click', function(event) {
                    event.stopPropagation(); // Prevent details/summary click
                    event.preventDefault();

                    const folderActionsDiv = this.closest('.folder-actions');
                    const folderName = folderActionsDiv.dataset.folderName;
                    const folderContainerElement = this.closest('.folder-item-container');


                    if (!folderName) {
                        alert('Error: Folder name not found.');
                        return;
                    }

                    if (window.confirm(`Are you sure you want to delete the folder "${folderName}"?`)) {
                        fetch(`/api/folder/delete/`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': '{{ csrf_token }}'
                            },
                            body: JSON.stringify({ folder_name: folderName })
                        })
                        .then(response => {
                            if (!response.ok) {
                                return response.json().then(err => { throw new Error(err.error || `HTTP error! status: ${response.status}`) });
                            }
                            return response.json();
                        })
                        .then(data => {
                            if (data.status === 'success') {
                                // Remove the folder from the UI.
                                // This might require a more robust way to update the list, e.g., re-fetching or page reload.
                                // For now, just remove the element.
                                if (folderContainerElement) {
                                    folderContainerElement.remove();
                                }
                                // alert(data.message + " Please refresh the page if items don't appear correctly in 'Other Chats'."); // Temp
                            } else {
                                alert('Error deleting folder: ' + (data.error || 'Unknown error'));
                            }
                        })
                        .catch(error => {
                            console.error('Error deleting folder:', error);
                            alert('Error deleting folder: ' + error.message);
                        });
                    }
                });
            });

            // Rename chat functionality
            document.querySelectorAll('.rename-chat-button').forEach(button => {
                button.addEventListener('click', function(event) {
                    event.stopPropagation(); // Prevent chat item click event
                    const chatItem = this.closest('.chat-item');
                    const chatLink = chatItem.querySelector('.chat-link');
                    const chatId = chatLink.dataset.chatId;
                    const originalFullTitle = chatItem.dataset.chatFullTitle;

                    // If an input is already there for this item, do nothing
                    if (chatItem.querySelector('.chat-title-input')) {
                        return;
                    }

                    chatLink.style.display = 'none';

                    const chatActionsDivForHiding = chatItem.querySelector('.chat-actions');
                    if (chatActionsDivForHiding) {
                        chatActionsDivForHiding.style.display = 'none';
                    }

                    const inputElement = document.createElement('input');
                    inputElement.type = 'text';
                    inputElement.value = originalFullTitle;
                    inputElement.classList.add('chat-title-input', 'bg-gray-700', 'text-white', 'p-1', 'rounded', 'text-sm', 'w-full', 'flex-grow'); // Added flex-grow
                    
                    // Insert input before the chat-actions div
                    const chatActionsDiv = chatItem.querySelector('.chat-actions');
                    chatItem.insertBefore(inputElement, chatActionsDiv);
                    
                    inputElement.focus();
                    inputElement.select();

                    function revertToDisplay() {
                        if (chatItem.contains(inputElement)) {
                            chatItem.removeChild(inputElement);
                        }
                        chatLink.style.display = '';

                        const chatActionsDivForRestoring = chatItem.querySelector('.chat-actions');
                        if (chatActionsDivForRestoring) {
                            // chat-actions are normally 'flex' when visible, and 'hidden' (display:none) otherwise.
                            // The 'hidden' class is managed by the main chat item click logic.
                            // If this chatItem is the currentActiveChatLi, it means its actions should be visible.
                            if (chatItem === currentActiveChatLi) {
                                chatActionsDivForRestoring.style.display = 'flex';
                            } else {
                                // If it's not the active chat, its actions should remain hidden.
                                // This case might be rare if rename is only allowed on active,
                                // but good for robustness.
                                chatActionsDivForRestoring.style.display = 'none';
                            }
                        }
                    }

                    inputElement.addEventListener('keypress', function(e) {
                        if (e.key === 'Enter') {
                            e.preventDefault(); // Prevent form submission if any
                            const newTitle = inputElement.value.trim();
                            if (newTitle && newTitle !== originalFullTitle) {
                                fetch(`/api/chat/${chatId}/rename_title/`, {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'X-CSRFToken': '{{ csrf_token }}'
                                    },
                                    body: JSON.stringify({ new_title: newTitle })
                                })
                                .then(response => {
                                    if (!response.ok) {
                                        return response.json().then(err => { throw new Error(err.error || `HTTP error! status: ${response.status}`) });
                                    }
                                    return response.json();
                                })
                                .then(data => {
                                    if (data.status === 'success') {
                                        chatLink.textContent = data.new_title.substring(0, 25) + (data.new_title.length > 25 ? '...' : '');
                                        chatItem.dataset.chatFullTitle = data.new_title; // Update the full title
                                        revertToDisplay();
                                    } else {
                                        alert('Error renaming chat: ' + (data.error || 'Unknown error'));
                                        revertToDisplay(); // Revert on error
                                    }
                                })
                                .catch(error => {
                                    console.error('Error renaming chat:', error);
                                    alert('Error renaming chat: ' + error.message);
                                    revertToDisplay(); // Revert on error
                                });
                            } else {
                                revertToDisplay(); // No change or empty title, just revert
                            }
                        }
                    });

                    inputElement.addEventListener('blur', function() {
                        // Timeout to allow click on potential save button or other actions
                        // For now, direct revert as per plan
                        setTimeout(revertToDisplay, 100); // Small delay to handle Enter press before blur
                    });
                    
                    inputElement.addEventListener('keydown', function(e) {
                        if (e.key === 'Escape') {
                            revertToDisplay();
                        }
                    });
                });
            });

            // Delete chat functionality
            document.querySelectorAll('.delete-chat-button').forEach(button => {
                button.addEventListener('click', function(event) {
                    event.stopPropagation(); // Prevent chat item click event
                    const chatIdToDelete = this.dataset.chatId;
                    const chatItemElement = this.closest('.chat-item'); // Get the <li> element

                    if (!chatIdToDelete) {
                        alert('Error: Chat ID not found for deletion.');
                        return;
                    }

                    if (window.confirm('Are you sure you want to delete this chat and all its messages?')) {
                        fetch(`/api/chat/${chatIdToDelete}/delete/`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': '{{ csrf_token }}'
                            },
                        })
                        .then(response => {
                            if (!response.ok) {
                                return response.json().then(err => { throw new Error(err.error || `HTTP error! status: ${response.status}`) });
                            }
                            return response.json();
                        })
                        .then(data => {
                            if (data.status === 'success') {
                                console.log('Chat deletion successful:', data.message);
                                if (chatItemElement) {
                                    chatItemElement.remove();
                                }
                                // If the deleted chat was the active one, try to select the next newest chat
                                if (currentChatId === chatIdToDelete) {
                                    const remainingChatItems = document.querySelectorAll('.chat-item');
                                    if (remainingChatItems.length > 0) {
                                        // The first item in the NodeList will be the top-most visible chat,
                                        // which corresponds to the newest due to Django's ordering.
                                        remainingChatItems[0].click(); // Programmatically click the new chat item
                                    } else {
                                        // No chats left, clear the display
                                        chatMessagesContainerEl.innerHTML = '<p class="text-gray-500 p-4">No chats available. Create a new one!</p>';
                                        if (chatModelSelectEl.options.length > 0) chatModelSelectEl.selectedIndex = 0; // Reset dropdown
                                        chatModelTempEl.textContent = 'N/A';
                                        // chatSystemPromptEl.textContent = 'No system prompt set.';
                                        currentChatId = null;
                                        currentActiveChatLi = null;
                                    }
                                }
                            } else {
                                alert('Error deleting chat: ' + (data.message || 'Unknown error'));
                            }
                        })
                        .catch(error => {
                            console.error('Error deleting chat:', error);
                            alert('Error deleting chat: ' + error.message);
                        });
                    }
                });
            });

            // Folder open/close state persistence
            document.querySelectorAll('details.folder-item-container').forEach(detailsElement => {
                detailsElement.addEventListener('toggle', function(event) {
                    const folderId = this.dataset.folderId;
                    if (!folderId) {
                        console.error('Folder ID not found for toggling state.');
                        return;
                    }
                    // The 'open' attribute is already changed by the browser at this point.
                    // We just need to inform the backend.
                    fetch(`/api/folder/${folderId}/toggle_open/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': '{{ csrf_token }}'
                        },
                        // No body needed, the backend toggles based on current state
                    })
                    .then(response => {
                        if (!response.ok) {
                            return response.json().then(err => { throw new Error(err.error || `HTTP error! status: ${response.status}`) });
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data.status === 'success') {
                            console.log(`Folder ${folderId} state updated to: ${data.is_open ? 'open' : 'closed'}`);
                        } else {
                            console.error('Error updating folder state:', data.error);
                            // Optionally, revert the toggle visually if the backend update fails,
                            // though this might be jarring for the user.
                            // For now, log the error.
                        }
                    })
                    .catch(error => {
                        console.error('Network error updating folder state:', error);
                    });
                });
            });

            // Drag and Drop Chat Functionality
            let draggedItem = null;

            document.querySelectorAll('.chat-item').forEach(item => {
                item.addEventListener('dragstart', function(event) {
                    draggedItem = event.target.closest('.chat-item');
                    event.dataTransfer.setData('text/plain', draggedItem.dataset.chatId);
                    setTimeout(() => { // Timeout to allow browser to capture the drag image
                        draggedItem.classList.add('is-dragging');
                    }, 0);
                });

                item.addEventListener('dragend', function(event) {
                    if (draggedItem) {
                        draggedItem.classList.remove('is-dragging');
                    }
                    draggedItem = null;
                    // Remove hover effect from all potential drop targets
                    document.querySelectorAll('.folder-drop-target').forEach(target => {
                        target.classList.remove('drop-hover');
                    });
                });
            });

            document.querySelectorAll('.folder-drop-target').forEach(target => {
                target.addEventListener('dragover', function(event) {
                    event.preventDefault(); // Necessary to allow dropping
                    target.classList.add('drop-hover');
                });

                target.addEventListener('dragleave', function(event) {
                    target.classList.remove('drop-hover');
                });

                target.addEventListener('drop', function(event) {
                    event.preventDefault();
                    target.classList.remove('drop-hover');
                    const chatId = event.dataTransfer.getData('text/plain');
                    const targetFolderId = target.dataset.folderId; // This will be folder ID or "other-chats-target"
                    
                    const itemToMove = draggedItem; // Capture the draggedItem at the moment of drop

                    if (!chatId || !itemToMove) {
                        console.error("Chat ID or dragged item not found at drop time.");
                        // If itemToMove is null here, it means dragend might have already cleared draggedItem.
                        // A page reload might be the safest recovery if itemToMove is null.
                        if (!itemToMove && chatId) { // If we have a chat ID but no item, something went wrong with drag state
                            console.warn("draggedItem was null but chatId present, reloading to reflect potential server-side changes.");
                            window.location.reload();
                        }
                        return;
                    }
                    
                    // Prevent dropping a chat into its current folder's list (visually it's already there)
                    const currentParentDropTarget = itemToMove.closest('.folder-drop-target');
                    if (currentParentDropTarget && currentParentDropTarget.dataset.folderId === targetFolderId) {
                        console.log("Chat is already in this folder.");
                        // Ensure is-dragging is removed if dragend didn't catch it due to early return
                        if(itemToMove) itemToMove.classList.remove('is-dragging');
                        return; // No action needed
                    }

                    fetch(`/api/chat/${chatId}/move_to_folder/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': '{{ csrf_token }}'
                        },
                        body: JSON.stringify({ target_folder_id: targetFolderId })
                    })
                    .then(response => {
                        if (!response.ok) {
                            return response.json().then(err => { throw new Error(err.error || `HTTP error! status: ${response.status}`) });
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data.status === 'success') {
                            // Move the chat item in the DOM
                            const targetList = target.querySelector('ul');
                            if (targetList) {
                                targetList.appendChild(itemToMove); // Use the captured itemToMove
                            } else {
                                // This case might happen if a folder is empty and has no <ul> yet,
                                // or if "Other Chats" is empty and its <ul> was removed or never created.
                                // For simplicity, we'll reload.
                                console.warn("Target list (ul) not found in the drop target, reloading page.");
                                window.location.reload();
                                return;
                            }
                            // If the chat was moved to "Other Chats", and "Other Chats" section wasn't visible,
                            // we might need to make it visible or just reload.
                            // For now, direct DOM move is attempted.
                            // A full page reload is a simpler way to ensure UI consistency after a move.
                            // window.location.reload(); // Uncomment for simpler update
                        } else {
                            alert('Error moving chat: ' + (data.error || 'Unknown error'));
                        }
                    })
                    .catch(error => {
                        console.error('Error moving chat:', error);
                        alert('Error moving chat: ' + error.message);
                    });
                });
            });

            // Event listener for chat model selection change
            if (chatModelSelectEl) {
                chatModelSelectEl.addEventListener('change', function() {
                    const selectedModelId = this.value;
                    if (!currentChatId) {
                        alert('Please select a chat first.');
                        // Optionally revert selection if no chat is active
                        // For now, we allow the change, but it won't be saved.
                        return;
                    }
                    if (!selectedModelId) {
                        alert('Invalid model selected.');
                        return;
                    }

                    fetch(`/api/chat/${currentChatId}/set_model/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': '{{ csrf_token }}'
                        },
                        body: JSON.stringify({ model_id: selectedModelId })
                    })
                    .then(response => {
                        if (!response.ok) {
                            return response.json().then(err => { throw new Error(err.error || `HTTP error! status: ${response.status}`) });
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data.status === 'success') {
                            // Optionally, provide user feedback (e.g., a small temporary notification)
                            console.log(`Chat model updated to ${data.new_model_name}`);
                            // The UI (dropdown) already reflects the change.
                            // If other parts of the UI depend on the model name directly (not just ID), they might need an update.
                            // For now, the dropdown itself is the primary indicator.
                        } else {
                            alert('Error updating chat model: ' + (data.error || 'Unknown error'));
                            // Optionally, revert the dropdown selection if the backend update fails.
                            // This would require storing the previous value.
                        }
                    })
                    .catch(error => {
                        console.error('Error updating chat model:', error);
                        alert('Error updating chat model: ' + error.message);
                        // Optionally, revert dropdown selection
                    });
                });
            }

        });
    </script>
    {% endblock %}
</body>
</html>
